{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../check/any-type.ts","webpack:///../check/array-of-type.ts","webpack:///../check/boolean-type.ts","webpack:///../check/element-with-tag-type.ts","webpack:///../check/enum-type.ts","webpack:///../check/finite-iterable-of-type.ts","webpack:///../check/finite-iterable-type.ts","webpack:///../check/has-properties-type.ts","webpack:///../check/has-property-type.ts","webpack:///../check/index.ts","webpack:///../check/instanceof-type.ts","webpack:///../check/intersect-type.ts","webpack:///../check/iterable-of-type.ts","webpack:///../check/iterable-type.ts","webpack:///../check/non-null-type.ts","webpack:///../check/null-type.ts","webpack:///../check/nullable-type.ts","webpack:///../check/number-type.ts","webpack:///../check/object-type.ts","webpack:///../check/string-type.ts","webpack:///../check/symbol-type.ts","webpack:///../check/tuple-of-type.ts","webpack:///../check/undefined-type.ts","webpack:///../check/union-type.ts","webpack:///../data/a-serializable.ts","webpack:///../data/annotations.ts","webpack:///../data/cache.ts","webpack:///../data/caches.ts","webpack:///../data/index.ts","webpack:///../data/jsons.ts","webpack:///../dispose/base-disposable.ts","webpack:///../dispose/disposable-function.ts","webpack:///../dispose/index.ts","webpack:///../error/assertion-error.ts","webpack:///../error/errors.ts","webpack:///../error/index.ts","webpack:///../graph/debug.ts","webpack:///../graph/flags.ts","webpack:///../graph/g-node.ts","webpack:///../graph/graph-event-handler.ts","webpack:///../graph/graph-time-node.ts","webpack:///../graph/graph-time.ts","webpack:///../graph/graph.ts","webpack:///../graph/index.ts","webpack:///../graph/inner-node.ts","webpack:///../graph/input-node.ts","webpack:///../graph/instance-id.ts","webpack:///../graph/node-in.ts","webpack:///../graph/node-out.ts","webpack:///../graph/static-id.ts","webpack:///../graph/test-graph.ts","webpack:///../immutable/generators.ts","webpack:///../immutable/immutable-list.ts","webpack:///../immutable/immutable-map.ts","webpack:///../immutable/immutable-set.ts","webpack:///../immutable/index.ts","webpack:///../immutable/iterables.ts","webpack:///../immutable/ordered-map.ts","webpack:///../immutable/ordered-set.ts","webpack:///../immutable/orderings.ts","webpack:///../immutable/tree-map.ts","webpack:///../immutable/tree-set.ts","webpack:///../immutable/vector2d.ts","webpack:///../inject/inject-util.ts","webpack:///../inject/injector.ts","webpack:///../jasmine/any-assert.ts","webpack:///../jasmine/array-assert.ts","webpack:///../jasmine/assert-color.ts","webpack:///../jasmine/assert-factory.ts","webpack:///../jasmine/assert.ts","webpack:///../jasmine/base-assert.ts","webpack:///../jasmine/boolean-assert.ts","webpack:///../jasmine/color-assert.ts","webpack:///../jasmine/element-assert.ts","webpack:///../jasmine/finite-iterable-assert.ts","webpack:///../jasmine/function-assert.ts","webpack:///../jasmine/iterable-assert.ts","webpack:///../jasmine/map-assert.ts","webpack:///../jasmine/matchers.ts","webpack:///../jasmine/number-assert.ts","webpack:///../jasmine/promise-assert.ts","webpack:///../jasmine/set-assert.ts","webpack:///../jasmine/string-assert.ts","webpack:///../mock/fakes.ts","webpack:///../mock/mocks.ts","webpack:///../parse/float-parser.ts","webpack:///../path/absolute-path-parser.ts","webpack:///../path/absolute-path.ts","webpack:///../path/index.ts","webpack:///../path/path-parser.ts","webpack:///../path/path.ts","webpack:///../path/paths.ts","webpack:///../path/relative-path-parser.ts","webpack:///../path/relative-path.ts","webpack:///../path/testing/index.ts","webpack:///../path/testing/path-matcher.ts","webpack:///../test-base.ts","webpack:///../testing/index.ts","webpack:///../testing/matcher-test-setup.ts","webpack:///../testing/test-async.ts","webpack:///../testing/test-dispose.ts","webpack:///../testing/test-event.ts","webpack:///../testing/test-inject.ts","webpack:///../testing/test-jasmine.ts","webpack:///../testing/test-setup.ts","webpack:///../typescript/assert-unreachable.ts","webpack:///../typescript/deprecated.ts","webpack:///../typescript/enums.ts","webpack:///../typescript/equals.ts","webpack:///../typescript/force-import.ts","webpack:///../typescript/index.ts","webpack:///../typescript/is-descendant-of.ts","webpack:///../util/hash.ts","webpack:///../util/index.ts","webpack:///../util/log.ts","webpack:///../util/reflect.ts","webpack:///./asyncs.ts","webpack:///./atomic.ts","webpack:///./atomic_test.ts","webpack:///./sequencer.ts","webpack:///external \"jasmine\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","AnyType","check","_","toString","instanceof_type_1","ArrayOfType","type","target","InstanceofType","Array","every","element","BooleanType","Boolean","ElementWithTagType","tag","HTMLElement","tagName","toLowerCase","EnumType","enumType","undefined","finite_iterable_type_1","FiniteIterableOfType","[object Object]","FiniteIterableType","item","has_property_type_1","intersect_type_1","iterable_type_1","IntersectType","builder","addType","IterableType","HasPropertyType","Function","build","HasPropertiesType","spec","key","entries","push","join","any_type_1","array_of_type_1","boolean_type_1","element_with_tag_type_1","enum_type_1","finite_iterable_of_type_1","has_properties_type_1","iterable_of_type_1","IterableOfType","non_null_type_1","NonNullType","null_type_1","NullType","nullable_type_1","NullableType","number_type_1","NumberType","object_type_1","ObjectType","string_type_1","StringType","symbol_type_1","SymbolType","tuple_of_type_1","TupleOfType","undefined_type_1","UndefinedType","union_type_1","UnionType","ctor","IntersectTypeBuilder","this","types_","slice","types","map","Symbol","iterator","Number","GenericObjectType","keyType_","valueType_","numberKeyed","valueType","stringKeyed","String","index","immutable_list_1","UnionTypeBuilder","ImmutableList","of","some","immutable_map_1","__FIELDS","__NAME","__PARENT","TYPE_FIELD","CTORS","Map","initField_","obj","Serializer","json","defaultInstance","jsonKey","getFields_","jsonValue","fromJSON","ImmutableMap","addAll","serializedName","constructor","toJSON","Serializable","parent","set","Field","propertyKey","immutable_set_1","hash_1","AnnotationsHandler","annotation","annotation_","parent_","propertyValues_","values","Set","add","getAttachedValues","keys","ImmutableSet","fluentMappable","parentAnnotationValues","hash","REGISTERED_ANNOTATIONS_","has","createHash_","handler","parentProto","getPrototypeOf","newHandler","Annotations","hasAnnotation","caches_1","error_1","cache","descriptor","Errors","assert","shouldBeAnInstanceOf","butWas","args","Caches","getCache","argsHash","arg","cachedValue","result","apply","setCacheValue","CACHE_ANNOTATIONS","forCtor","attachValueToProperty","annotations_1","__CACHES","instance","getCache_","clear","getAnnotatedProperties","caches","getCaches","a_serializable_1","cache_1","jsons_1","Jsons","deprecated_1","LOG","Log","original","clone","JSON","parse","stringify","path","parts","split","length","fromObj","toObj","mixin","deepClone","should","propertyName","pop","forEach","part","__decorate","deprecated","TRACKED_DISPOSABLES","Flags","enableTracking","BaseDisposable","disposables_","isDisposed_","disposables","disposable","disposeInternal","dispose","indexOf","splice","base_disposable_1","DisposableFunction","fn","super","fn_","run","disposable_function_1","AssertionShouldBuilder","fieldName_","condition_","createAssertionError_","actual","but","AssertionError","AssertionBuilder","condition","expected","Error","message","setPrototypeOf","assertion_error_1","fieldName","errors_1","data_1","graph_1","immutable_1","Debug","id","context","node","Graph","getNode_","shouldExist","valueMap","time","value_","parameters","getParameterIds","trace","DebugNode","setValue","window","FLAGS","checkValueType","dispose_1","GLOBALS","GNode","parameterIds_","cacheMap_","timestamp","params","normalizedContext","execute_","addToCache_","filter","beforeOrEqualTo","reduce","prev","g_node_1","GraphEventHandler","onChangeListeners_","WeakMap","onReadyListeners_","listeners","handlers","getHandlers_","event","callHandlers_","size","delete","modifyHandlers_","GraphTimeNode","_context","_params","check_1","static_id_1","GraphTime","timestamp_","other","$time","staticId","flags_1","graph_event_handler_1","graph_time_1","graph_time_node_1","inner_node_1","input_node_1","instance_id_1","typescript_1","util_1","LOGGER","GraphImpl","currentTime_","new","monitoredNodes_","nodes_","setQueue_","transitiveDependencies_","eventHandler_","addDisposable","nodeId","initValue","InputNode","StaticId","newValue","set_","debug","idealExecutionTime","getIdealExecutionTime_","latestCacheValue","getLatestCacheValue","Promise","all","parameterId","InnerNode","isMonitored_","dependencyId","getTransitiveDependencies_","onReady_","onReady","ids","execute","resolvedCached","resolvedValue","getType","equals","InstanceId","dispatchChange","nodeIds","parameterIds","entry","times","current","getAt","existingDependencies","butNot","dependencies","paramId","dependency","deps","onChange","refresh","promises","setFn","resolve","setTimeout","assertNodeExist_","dispatchReady","provider","existingNode","getProvider","shouldBe","existingArgs","newArgs","maxIndex","Math","max","existingArg","registerGenericProvider_","promise","newTime","increment","processSetQueue_","debug_1","instanceId","node_in_1","nodeIn","node_out_1","nodeOut","test_graph_1","TestGraph","initValue_","symbol_","debug_","type_","ANNOTATIONS","paramsSet","paramsArray","originalMap","originalCheckValueType","createProvider","Generators","from","step","to","orderings_1","data","data_","items","toDeleteIndexes","sort","index1","index2","reverse","deleteKey","checker","newItems","findValue","findEntry","normalizedIndex","toAdds","toAdd","ordering","reduceItem","prevValue","Orderings","init","start","end","normalizedEnd","normalizedStart","sliceData","loopBound","min","compareFn","mapItem","ItemListType","array","DataTransferItemList","assertUnreachable","ordered_map_1","everyItem","filterItem","mappedEntries","currentEntry","someItem","OrderedMap","iterables_1","ordered_set_1","assert_unreachable_1","Iterables","iterable","arrayData","OrderedSet","generators_1","tree_map_1","TreeMap","tree_set_1","TreeSet","vector2d_1","Vector2d","iterables","output","ITERATOR_TYPE","iterable1","iterable2","array1","array2","item1","item2","unsafeEquals","keys_","map_","keysClone","mapClone","entriesToAdd","hasKey","deleteAll","keyToDelete","deleteAllKeys","thisKey","thisValue","otherKey","otherValue","filteredEntries","keysToInsert","insertAllAt","deleteAt","insertAt","key1","key2","value1","value2","itemsToAdd","preInsertionCount","existingIndex","curr","uniques","float_parser_1","NATURAL_SPLIT_REGEXP","compound","orderings","mapFn","matches","matchFn","matches1","matches2","checked","checkedSet","natural","item1Chunks","item2Chunks","maxLength","normal","normalize","str","parsed","FloatParser","passes1","passes2","childNodes_","getValue","mapHelper_","newKey","newChildren","filterByType","postOrder","descendants","preOrder","children","tree","results","resultsMap","mapContent","child","x","y","sqrt","getLengthSquared","__METADATA","InjectUtil","reflect_1","inject_util_1","INJECTOR_BIND_KEY_","Injector","instances_","bindKey","isOptional","BINDINGS_","extraArguments","metadataMap","getMetadataMap","metadata","getBoundValue","getKeyName","Reflect","construct","getParameters","bindProvider","injector","instantiate","base_assert_1","AnyAssert","BaseAssert","getMatchers_","toBe","clazz","toEqual","jasmine","any","toBeDefined","toBeFalsy","toBeNull","toBeTruthy","objectContaining","iterable_assert_1","ArrayAssert","IterableAssert","arrayValue","reversed","expect","toContain","assert_factory_1","color_assert_1","assertColor","AssertFactory","ColorAssert","provider_","toNot","any_assert_1","array_assert_1","boolean_assert_1","element_assert_1","finite_iterable_assert_1","function_assert_1","map_assert_1","number_assert_1","promise_assert_1","set_assert_1","string_assert_1","BooleanAssert","StringAssert","NumberAssert","Element","ElementAssert","FunctionAssert","MapAssert","SetAssert","PromiseAssert","fail","FiniteIterableAssert","anyValue_","reversed_","expect_","not","booleanValue","be","color","colorValue_","hue","saturation","lightness","hslArray","getHue","getSaturation","getLightness","red","green","blue","rgbArray","getRed","getGreen","getBlue","elementValue","elementValue_","expectedChildren","expectedClasses","classes","classList","finiteIterableValue_","elements","functionValue","toHaveBeenCalled","toHaveBeenCalledTimes","haveBeenCalledWith","matchers","toHaveBeenCalledWith","toThrow","regexp","toThrowError","iterableValue_","toCheck","next","done","mapValue","mapValue_","MatcherBuilder","mapFns_","createMatcher_","anything","arrayContaining","asymmetricMatcher","asymmetricMatch","mappedActual","previous","fns","stringMatching","Matchers","precision","toBeCloseTo","promise_","fail_","e","errorMsg","rejectWithErrorType","errorType","error","toMatch","resolveValue","setValue_","stringValue","WhenBuilder","spy","callSpecs","args_","callSpecs_","spy_","newCallSpecs","concat","and","callFake","callSpec","find","jasmineMatches","FakesContinuationBuilder","return","ElseBuilder","whenBuilder_","Fakes","else","__id","Mocks","methods","baseObj","method","mock","on","dispatch","getEventTarget","objType","input","parseFloat","isNaN","absolute_path_1","path_1","AbsolutePathParser","Path","SEPARATOR","AbsolutePath","getParts","absolute_path_parser_1","path_parser_1","PathParser","paths_1","Paths","relative_path_1","RelativePath","relative_path_parser_1","RelativePathParser","parts_","pathString","filename","extensionIndex","extension","srcPath","destPath","commonCount","thisParts","thatParts","upCount","subpaths","currentPath","getDirPath","root","paths","srcParts","noEmptyParts","noCurrentParts","nonDoubleDotEntry","nonDoubleIndex","normalizedParts","getFilenameParts","path_matcher_1","PathMatcher","testing_1","pathString_","testSetup","matcherTestSetup","testing_2","log_1","assert_1","assert_color_1","matchers_1","fakes_1","mocks_1","TEST_SETUP","TestSetup","TestAsync","TestDispose","TestEvent","TestJasmine","initialized","TestBase","setup","setEnabledLevel","LogLevel","OFF","matcher_test_setup_1","test_async_1","test_dispose_1","test_event_1","test_inject_1","TestInject","test_jasmine_1","test_setup_1","addCustomEqualityTester","first","second","asyncs_1","spyOn","Asyncs","DISPOSABLES","__calls","eventType","eventTypes","payload","injector_1","BOUND_VALUES_","setColorEnabled","runTest","origRun","description","callback","then","bind","fit","it","setups","setups_","beforeEach","afterEach","log","origValue","warn","Enums","enumSet","toUpperCase","enumValue","forceImport","console","enums_1","equals_1","force_import_1","is_descendant_of_1","isDescendantOf","descendantCtor","ancestorCtor","HASHED_VALUES","HASHED_OBJECTS","lastHash","mapLike","namespace","currentIds_","loggedIds_","namespace_","logLevel","messages","currentId","ENABLED_LOG_LEVEL_","usedColor","COLOR_ENABLED_","callIfEnabled_","DEBUG","ERROR","groupCollapsed","INFO","groupEnd","info","enabled","WARNING","initializer","origInitializer","__initialize","sequencer_1","__SEQUENCER","atomic","originalFn","sequencer","Sequencer","newInstance","test_base_1","atomic_1","describe","decorator","__awaiter","mockFunction","createSpy","mockSequencer","createSpyObj","returnValue","newDescriptor","Class","equal","mockInstance","anyFunction","calls","argsFor","throwError","lastOperation_","operation","newPromise","isDisposed","catch"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./atomic_test.ts\");\n","import { Type } from '../check/type';\n\nexport function AnyType<T>(): Type<T> {\n  return {\n    check(_: any): _ is T {\n      return true;\n    },\n\n    toString(): string {\n      return '(any)';\n    },\n  };\n}\n","import { InstanceofType } from '../check/instanceof-type';\nimport { Type } from '../check/type';\n\n/**\n * Checks if the elements of the given array are all of the given type.\n *\n * @param type Type of the elements.\n * @param <T> Type of the element.\n * @return The array type.\n */\nexport function ArrayOfType<T>(type: Type<T>): Type<T[]> {\n  return {\n    /**\n     * @override\n     */\n    check(target: any): target is T[] {\n      if (InstanceofType(Array).check(target)) {\n        return target.every((element: any) => {\n          return type.check(element);\n        });\n      } else {\n        return false;\n      }\n    },\n\n    toString(): string {\n      return `${type}[]`;\n    },\n  };\n}\n","import { Type } from '../check/type';\n\nexport const BooleanType: Type<boolean> = {\n  /**\n   * @override\n   */\n  check(target: any): target is boolean {\n    return typeof target === 'boolean' || target instanceof Boolean;\n  },\n\n  toString(): string {\n    return 'boolean';\n  },\n};\n","import { Type } from '../check';\n\nexport function ElementWithTagType(tag: string): Type<HTMLElement> {\n  return {\n    check(target: any): target is HTMLElement {\n      if (!(target instanceof HTMLElement)) {\n        return false;\n      }\n\n      return target.tagName.toLowerCase() === tag.toLowerCase();\n    },\n\n    toString(): string {\n      return `HTMLElement(${tag})`;\n    },\n  };\n}\n","import { Type } from '../check';\n\nexport function EnumType<E>(enumType: gs.IEnum): Type<E> {\n  return {\n    check(target: any): target is E {\n      return enumType[target] !== undefined;\n    },\n\n    toString(): string {\n      return `Enum`;\n    },\n  };\n}\n","import { FiniteIterableType } from '../check/finite-iterable-type';\nimport { Type } from '../check/type';\nimport { Finite } from '../interfaces/finite';\n\nexport function FiniteIterableOfType<T, I extends Finite & Iterable<T>>(type: Type<T>):\n    Type<I> {\n  return {\n    check(target: any): target is I {\n      if (!FiniteIterableType.check(target)) {\n        return false;\n      }\n\n      for (const item of target) {\n        if (!type.check(item)) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n\n    toString(): string {\n      return `(Finite & Iterable<${type}>)`;\n    },\n  };\n}\n","import { HasPropertyType } from '../check/has-property-type';\nimport { InstanceofType } from '../check/instanceof-type';\nimport { IntersectType } from '../check/intersect-type';\nimport { IterableType } from '../check/iterable-type';\nimport { Finite } from '../interfaces/finite';\n\nexport const FiniteIterableType = IntersectType.builder<Finite & Iterable<any>>()\n    .addType(IterableType)\n    .addType(HasPropertyType<Finite>('size', InstanceofType(Function)))\n    .build();\n// TODO: Mutable\n","import { Type } from '../check/type';\n\nexport function HasPropertiesType<OBJ>(spec: {[KEY in keyof OBJ]: Type<OBJ[KEY]>}): Type<OBJ> {\n  return {\n    check(target: any): target is OBJ {\n      if (!(target instanceof Object)) {\n        return false;\n      }\n\n      for (const key in spec) {\n        if (!spec[key].check(target[key])) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n\n    toString(): string {\n      const entries: string[] = [];\n      for (const key in spec) {\n        entries.push(`${key}: ${spec[key]}`);\n      }\n      return `{${entries.join(', ')}}`;\n    },\n  };\n}\n","import { Type } from '../check/type';\n\n// TODO: Delete\nexport function HasPropertyType<T>(name: string | symbol, type: Type<any>): Type<T> {\n  return {\n    /**\n     * @override\n     */\n    check(target: any): target is T {\n      if (!target) {\n        return false;\n      }\n\n      const value = target[name];\n      return value !== undefined && type.check(value);\n    },\n\n    toString(): string {\n      return `{${name}: ${type}}`;\n    },\n  };\n}\n","export { AnyType } from './any-type';\nexport { ArrayOfType } from './array-of-type';\nexport { BooleanType } from './boolean-type';\nexport { ElementWithTagType } from './element-with-tag-type';\nexport { EnumType } from './enum-type';\nexport { FiniteIterableType } from './finite-iterable-type';\nexport { FiniteIterableOfType } from './finite-iterable-of-type';\nexport { HasPropertiesType } from './has-properties-type';\nexport { HasPropertyType } from './has-property-type';\nexport { InstanceofType } from './instanceof-type';\nexport { IntersectType } from './intersect-type';\nexport { IterableOfType } from './iterable-of-type';\nexport { IterableType } from './iterable-type';\nexport { Type } from './type';\nexport { NonNullType } from './non-null-type';\nexport { NullType } from './null-type';\nexport { NullableType } from './nullable-type';\nexport { NumberType } from './number-type';\nexport { ObjectType } from './object-type';\nexport { StringType } from './string-type';\nexport { SymbolType } from './symbol-type';\nexport { TupleOfType } from './tuple-of-type';\nexport { UndefinedType } from './undefined-type';\nexport { UnionType } from './union-type';\n","import { Type } from '../check/type';\n\n\n/**\n * Checks if the target is an instance of the given ctor.\n * @param ctor Ctor to check the type.\n * @return The instanceof type.\n */\nexport function InstanceofType<T>(ctor: gs.ICtor<T> | Function): Type<T> {\n  return {\n    /**\n     * @override\n     */\n    check(target: any): target is T {\n      return target instanceof ctor;\n    },\n\n    toString(): string {\n      return `(instanceof ${ctor.name})`;\n    },\n  };\n}\n","import { Type } from '../check/type';\n\nclass IntersectTypeBuilder<T> {\n  private readonly types_: Type<any>[];\n\n  constructor() {\n    this.types_ = [];\n  }\n\n  /**\n   * Adds the given type as a requirement to check.\n   * @param type Type to check.\n   */\n  addType(type: Type<any>): IntersectTypeBuilder<T> {\n    this.types_.push(type);\n    return this;\n  }\n\n  /**\n   * Builds the Intersect type object.\n   * @return New instance of IntersectType.\n   */\n  build(): IntersectType<T> {\n    return new IntersectType(this.types_.slice());\n  }\n}\n\n/**\n * Checks if a target satisfies all of the conditions.\n *\n * This lets you add a set of types that must be satisfied for the checked object to be treated as\n * type T.\n * @param <T> Type to check.\n */\nexport class IntersectType<T> implements Type<T> {\n  private readonly types_: Type<T>[];\n\n  /**\n   * @param types Types that the checked object should satisfy.\n   */\n  constructor(types: Type<T>[]) {\n    this.types_ = types;\n  }\n\n  /**\n   * @override\n   */\n  check(target: any): target is T {\n    return this.types_.every((type: Type<T>) => {\n      return type.check(target);\n    });\n  }\n\n  toString(): string {\n    const types = this.types_.map((type: Type<T>) => `${type}`).join(' & ');\n    return `(${types})`;\n  }\n\n  /**\n   * Creates a new builder for the intersect type.\n   * @param <T> Type to check.\n   * @return The builder for IntersectType.\n   */\n  static builder<T>(): IntersectTypeBuilder<T> {\n    return new IntersectTypeBuilder<T>();\n  }\n}\n// TODO: Mutable\n","import { HasPropertiesType } from '../check/has-properties-type';\nimport { InstanceofType } from '../check/instanceof-type';\nimport { Type } from '../check/type';\n\nconst IterableType = HasPropertiesType<Iterable<any>>(\n    {[Symbol.iterator]: InstanceofType(Function)});\n\nexport function IterableOfType<T, I extends Iterable<T>>(type: Type<T>): Type<I> {\n  return {\n    check(target: any): target is I {\n      if (!IterableType.check(target)) {\n        return false;\n      }\n\n      for (const item of target) {\n        if (!type.check(item)) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n\n    toString(): string {\n      return `Iterable<${type}>`;\n    },\n  };\n}\n","import { HasPropertyType } from '../check/has-property-type';\nimport { InstanceofType } from '../check/instanceof-type';\n\n// TODO: DELETE\n\nexport const IterableType = HasPropertyType<Iterable<any>>(\n    Symbol.iterator, InstanceofType(Function));\n","import { Type } from '../check/type';\n\n\n/**\n * Checks if the target is non null.\n * @return The non null type.\n */\nexport function NonNullType<T>(): Type<T> {\n  return {\n    /**\n     * @override\n     */\n    check(target: any): target is T {\n      return target !== null;\n    },\n\n    toString(): string {\n      return '(!== null)';\n    },\n  };\n}\n","import { Type } from '../check';\n\nexport const NullType: Type<null> = {\n  /**\n   * @override\n   */\n  check(target: any): target is null {\n    return target === null;\n  },\n\n  toString(): string {\n    return 'null';\n  },\n};\n","import { NullType } from '../check/null-type';\nimport { Type } from '../check/type';\nimport { UnionType } from '../check/union-type';\n\nexport function NullableType<T>(type: Type<T>): Type<T | null> {\n  return UnionType.builder<T | null>()\n      .addType(type)\n      .addType(NullType)\n      .build();\n}\n","import { Type } from '../check/type';\n\nexport const NumberType: Type<number> = {\n  /**\n   * @override\n   */\n  check(target: any): target is number {\n    return typeof target === 'number' || target instanceof Number;\n  },\n\n  toString(): string {\n    return 'number';\n  },\n};\n","import { InstanceofType } from '../check/instanceof-type';\nimport { NumberType } from '../check/number-type';\nimport { StringType } from '../check/string-type';\nimport { Type } from '../check/type';\n\nclass GenericObjectType<T> {\n  constructor(\n      private readonly keyType_: Type<any>,\n      private readonly valueType_: Type<any>) { }\n\n  check(target: any): target is T {\n    if (!InstanceofType(Object).check(target)) {\n      return false;\n    }\n\n    for (const key in target) {\n      if (!this.keyType_.check(key)) {\n        return false;\n      }\n\n      if (!this.valueType_.check(target[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  toString(): string {\n    return `{[key: ${this.keyType_}]: ${this.valueType_}}`;\n  }\n}\n\nexport const ObjectType = {\n  numberKeyed<V>(valueType: Type<V>): Type<{[key: number]: V}> {\n    return new GenericObjectType<{[key: number]: V}>(NumberType, valueType);\n  },\n\n  stringKeyed<V>(valueType: Type<V>): Type<{[key: string]: V}> {\n    return new GenericObjectType<{[key: string]: V}>(StringType, valueType);\n  },\n};\n","import { Type } from '../check/type';\n\nexport const StringType: Type<string> = {\n  /**\n   * @override\n   */\n  check(target: any): target is string {\n    return typeof target === 'string' || target instanceof String;\n  },\n\n  toString(): string {\n    return 'string';\n  },\n};\n","import { Type } from '../check/type';\n\nexport const SymbolType: Type<symbol> = {\n  /**\n   * @override\n   */\n  check(target: any): target is symbol {\n    return typeof target === 'symbol';\n  },\n\n  toString(): string {\n    return 'symbol';\n  },\n};\n","import { Type } from '../check/type';\n\nexport function TupleOfType<T0>(spec: [Type<T0>]): Type<[T0]>;\nexport function TupleOfType<T0, T1>(spec: [Type<T0>, Type<T1>]): Type<[T0, T1]>;\nexport function TupleOfType(spec: Type<any>[]): Type<any[]> {\n  return {\n    check(target: any): target is any[] {\n      if (!(target instanceof Object)) {\n        return false;\n      }\n\n      return spec.every((type: Type<any>, index: number) => {\n        return type.check(target[index]);\n      });\n    },\n\n    toString(): string {\n      return `[${spec.map((type: Type<any>) => `${type}`).join(', ')}]`;\n    },\n  };\n}\n","import { Type } from '../check';\n\nexport const UndefinedType: Type<undefined> = {\n  /**\n   * @override\n   */\n  check(target: any): target is undefined {\n    return target === undefined;\n  },\n\n  toString(): string {\n    return 'undefined';\n  },\n};\n","import { Type } from '../check/type';\nimport { ImmutableList } from '../immutable/immutable-list';\n\nclass UnionTypeBuilder<T> {\n  private readonly types_: Type<any>[];\n\n  constructor() {\n    this.types_ = [];\n  }\n\n  /**\n   * Adds the given type as a requirement to check.\n   * @param type Type to check.\n   */\n  addType<S extends T>(type: Type<S>): UnionTypeBuilder<T> {\n    this.types_.push(type);\n    return this;\n  }\n\n  /**\n   * Builds the Union type object.\n   * @return New instance of UnionType.\n   */\n  build(): UnionType<T> {\n    return new UnionType(this.types_.slice());\n  }\n}\n\n/**\n * Checks if a target satisfies at least one of the conditions.\n *\n * This lets you add a set of types where at least one must be satisfied for the checked object to\n * be treated as type T.\n * @param <T> Type to check.\n */\nexport class UnionType<T> implements Type<T> {\n  private readonly types_: Type<T>[];\n\n  /**\n   * @param types Types that the checked object should satisfy.\n   */\n  constructor(types: Type<T>[]) {\n    this.types_ = types;\n  }\n\n  /**\n   * @override\n   */\n  check(target: any): target is T {\n    return ImmutableList\n        .of(this.types_)\n        .some((type: Type<T>) => {\n          return type.check(target);\n        });\n  }\n\n  toString(): string {\n    const types = this.types_.map((type: Type<T>) => `${type}`).join(' | ');\n    return `(${types})`;\n  }\n\n  /**\n   * Creates a new builder for the union type.\n   * @param <T> Type to check.\n   * @return The builder for UnionType.\n   */\n  static builder<T>(): UnionTypeBuilder<T> {\n    return new UnionTypeBuilder<T>();\n  }\n}\n","/**\n * Provides a convenient way to serialize / deserialize objects to / from JSON.\n *\n * This uses three different parts:\n *\n * 1.  [[Serializable]]: This annotates the class to be serializable. You will need to give the\n *     class a unique ID for serialization.\n * 1.  [[Field]]: This annotates fields in the class as serializable. Like [[Serializable]], each\n *     field also needs an ID that uniquely identifies the field in the class. Note that the field\n *     has to be JSON serializable, or is annotated with [[Serializable]].\n * 1.  [[Serializer]]: This class actually does the conversion from / to JSON.\n *\n * Example class:\n *\n * ```typescript\n * // Ignore the \\, there is something wrong with the doc parser.\n * \\@Serializable('example')\n * class Example {\n *   @Field('fieldA') private fieldA_: number;\n *   @Field('fieldB') private fieldB_: string;\n *\n *   constructor(a?: number, b?: string) {\n *     this.fieldA_ = a;\n *     this.fieldB_ = b;\n *   }\n * }\n *\n * let example = new Example(1, 'b');\n * let json = Serializer.toJSON(example); // {_type: 'example', fieldA: 1, fieldB: 'b'}\n * Serializer.fromJSON(json); // This is the same as new Example(1, 'b');\n * ```\n *\n * Note that the class' constructor must be able to be called without any arguments.\n */\n\n/**\n * @hidden\n */\nimport { ImmutableMap } from '../immutable/immutable-map';\n\nconst __FIELDS = Symbol('fields');\n\n/**\n * @hidden\n */\nconst __NAME = Symbol('name');\n\nconst __PARENT = Symbol('parent');\n\n/**\n * @hidden\n */\nconst TYPE_FIELD = '_type';\n\n/**\n * @hidden\n */\nconst CTORS = new Map<string, any>();\n\n/**\n * @hidden\n */\nfunction initField_(obj: Object): void {\n  if (!obj[__FIELDS]) {\n    obj[__FIELDS] = new Map<string | symbol, string>();\n  }\n}\n\n/**\n * Manages conversion of serializable objects to / from JSON objects.\n */\nexport class Serializer {\n\n  /**\n   * Converts the given JSON object to a known [[Serializable]] object.\n   *\n   * @param json The JSON object to convert.\n   * @return The known [[Serializable]] object converted from the JSON object.\n   */\n  static fromJSON(json: gs.IJson): any {\n    if (!json) {\n      return json;\n    }\n\n    const ctor = CTORS.get(json[TYPE_FIELD]);\n    if (!!ctor) {\n      const defaultInstance = new ctor();\n\n      for (const [key, jsonKey] of Serializer.getFields_(ctor)) {\n        const jsonValue = json[jsonKey];\n        if (jsonValue !== undefined) {\n          defaultInstance[key] = this.fromJSON(jsonValue);\n        }\n      }\n\n      return defaultInstance;\n    } else if (json instanceof Array) {\n      return json.map((value: any) => this.fromJSON(value));\n    } else if (json instanceof Object) {\n      const obj = {};\n      for (const key in json) {\n        obj[key] = this.fromJSON(json[key]);\n      }\n      return obj;\n    } else {\n      return json;\n    }\n  }\n\n  /**\n   * Retrieves the fields for the given constructor.\n   */\n  private static getFields_(ctor: any): ImmutableMap<string, string> {\n    const fields = (ctor.prototype[__PARENT]) ?\n        Serializer.getFields_(ctor.prototype[__PARENT]) :\n        ImmutableMap.of<string, string>(new Map());\n\n    return fields.addAll(ctor.prototype[__FIELDS]);\n  }\n\n  static getRegisteredCtor(serializedName: string): any {\n    return CTORS.get(serializedName) || null;\n  }\n\n  static getSerializedName(ctor: any): string | null {\n    return ctor[__NAME] || null;\n  }\n\n  /**\n   * Converts the given [[Serializable]] object to JSON object.\n   *\n   * @param obj The [[Serializable]] object to convert.\n   * @return The JSON object corresponding to the [[Serializable]] object.\n   */\n  static toJSON(obj: any): gs.IJson {\n    if (!(obj instanceof Object)) {\n      return obj;\n    }\n\n    const ctor = obj.constructor;\n    if (!!ctor.prototype[__NAME]) {\n      const json = {[TYPE_FIELD]: ctor.prototype[__NAME]};\n      for (const [key, jsonKey] of Serializer.getFields_(ctor)) {\n        json[jsonKey] = this.toJSON(obj[key]);\n      }\n      return json;\n    } else if (obj instanceof Array) {\n      return obj.map((value: any) => this.toJSON(value));\n    } else {\n      const json = {};\n      for (const key in obj) {\n        json[key] = this.toJSON(obj[key]);\n      }\n      return json;\n    }\n  }\n}\n\n/**\n * Annotates a class and marks it as serializable.\n *\n * @param name Name of the class. This name should be unique within the binary.\n */\nexport function Serializable(name: string, parent: any = null): ClassDecorator {\n  // TODO(gs): Check uniqueness.\n  return function<F extends Function>(ctor: F): void {\n    CTORS.set(name, ctor);\n    initField_(ctor.prototype);\n    ctor.prototype[__NAME] = name;\n\n    if (parent !== null) {\n      ctor.prototype[__PARENT] = parent;\n    }\n  };\n}\n\n/**\n * Annotates a property in a [[Serializable]] class and marks it to be exported when converted to\n * JSON object.\n *\n * @param name Name of the field. This name must be unique within the class and must not start with\n *    `_`.\n */\nexport function Field(name: string): PropertyDecorator {\n  // TODO(gs): Assert that the name does not start with _\n  return function(target: Object, propertyKey: string | symbol): void {\n    initField_(target);\n    target[__FIELDS].set(propertyKey, name);\n  };\n}\n","import { ImmutableMap } from '../immutable/immutable-map';\nimport { ImmutableSet } from '../immutable/immutable-set';\nimport { hash } from '../util/hash';\n\n\n/**\n * Generic class to manage annotations.\n * @param <T> The type of value associated with the annotation.\n */\nexport class AnnotationsHandler<T> {\n  private static readonly REGISTERED_ANNOTATIONS_: Map<string, AnnotationsHandler<any>> = new Map();\n  private readonly annotation_: symbol;\n  private readonly parent_: any;\n  private readonly propertyValues_: Map<string | symbol, Set<T>>;\n\n  /**\n   * @param annotation The symbol to identify the annotation.\n   * @param parent Pointer to the parent class to follow the annotation.\n   */\n  constructor(annotation: symbol, parent: any) {\n    this.annotation_ = annotation;\n    this.parent_ = parent;\n    this.propertyValues_ = new Map<string | symbol, Set<T>>();\n  }\n\n  /**\n   * Adds the given value to the given property identifier.\n   *\n   * @param key Identifier of the property to attach the value to.\n   * @param value The value to attach to the given property.\n   */\n  attachValueToProperty(key: string | symbol, value: T): void {\n    let values = this.propertyValues_.get(key);\n    if (!values) {\n      values = new Set<T>();\n      this.propertyValues_.set(key, values);\n    }\n    values.add(value);\n  }\n\n  /**\n   * @return Names of properties with attached values.\n   */\n  getAnnotatedProperties(): ImmutableSet<string | symbol> {\n    return this.getAttachedValues().keys();\n  }\n\n  /**\n   * @return Map of property name to the value attached to that property.\n   */\n  getAttachedValues(): ImmutableMap<string | symbol, ImmutableSet<T>> {\n    const entries: [string | symbol, ImmutableSet<T>][] = [];\n    for (const [key, values] of this.propertyValues_) {\n      entries.push([key, ImmutableSet.of(values)] as [string | symbol, ImmutableSet<T>]);\n    }\n\n    const fluentMappable = ImmutableMap.of(entries);\n    if (this.parent_ !== null) {\n      const parentAnnotationValues = AnnotationsHandler\n          .of<T>(this.annotation_, this.parent_)\n          .getAttachedValues();\n      return fluentMappable.addAll(parentAnnotationValues);\n    } else {\n      return fluentMappable;\n    }\n  }\n\n  /**\n   * @param ctor The constructor to create the hash for.\n   * @param annotation The annotation symbol to create the hash for.\n   */\n  private static createHash_(ctor: any, annotation: symbol): string {\n    return `${hash(ctor)}_${hash(annotation)}`;\n  }\n\n  /**\n   * @param ctor The constructor to be checked.\n   * @param annotation The identifier of the annotation checked.\n   * @return True iff the given constructor has the given annotation identifier.\n   */\n  static hasAnnotation(ctor: any, annotation: symbol): boolean {\n    return AnnotationsHandler.REGISTERED_ANNOTATIONS_.has(\n        AnnotationsHandler.createHash_(ctor, annotation));\n  }\n\n  /**\n   * @param annotation The symbol to identify the annotation.\n   * @param proto The prototype to add the annotation to.\n   * @param parent Pointer to the parent class to follow the annotation.\n   */\n  static of<T>(annotation: symbol, ctor: any): AnnotationsHandler<T> {\n    const hash = AnnotationsHandler.createHash_(ctor, annotation);\n    const handler = AnnotationsHandler.REGISTERED_ANNOTATIONS_.get(hash);\n    if (handler !== undefined) {\n      return handler;\n    }\n\n    const parentProto = Object.getPrototypeOf(ctor.prototype);\n    const parent = parentProto === null ? null : parentProto.constructor;\n    const newHandler = new AnnotationsHandler<T>(annotation, parent);\n    AnnotationsHandler.REGISTERED_ANNOTATIONS_.set(hash, newHandler);\n    return newHandler;\n  }\n}\n\n/**\n * Generic class to manage annotations.\n */\nexport class Annotations<T> {\n  private annotation_: symbol;\n\n  /**\n   * @param annotation The symbol to identify the annotation.\n   */\n  constructor(annotation: symbol) {\n    this.annotation_ = annotation;\n  }\n\n  /**\n   * Creates a new handler for the given prototype.\n   *\n   * @param ctor The constructor to associate the annotation to.\n   * @return New instance of annotations handler for the given constructor.\n   */\n  forCtor(ctor: any): AnnotationsHandler<T> {\n    return AnnotationsHandler.of<T>(this.annotation_, ctor);\n  }\n\n  /**\n   * @return True iff the given constructor has the annotation.\n   */\n  hasAnnotation(ctor: any): boolean {\n    return AnnotationsHandler.hasAnnotation(ctor, this.annotation_);\n  }\n\n  /**\n   * Gets the annotations object for the given constructor.\n   *\n   * @param annotation The identifier of the annotation to be returned.\n   */\n  static of<T>(annotation: symbol): Annotations<T> {\n    return new Annotations<T>(annotation);\n  }\n}\n","import { CACHE_ANNOTATIONS, Caches } from '../data/caches';\nimport { Errors } from '../error';\nimport { hash } from '../util/hash';\n\n\n\nexport function cache(): MethodDecorator {\n  return function(\n      target: Object,\n      propertyKey: string | symbol,\n      descriptor: TypedPropertyDescriptor<any>): TypedPropertyDescriptor<any> {\n    const value = descriptor.value;\n    if (!(value instanceof Function)) {\n      throw Errors.assert('attached').shouldBeAnInstanceOf(Function).butWas(value);\n    }\n\n    descriptor.value = function(...args: any[]): any {\n      const cache = Caches.getCache(this, propertyKey);\n      const argsHash = args\n          .map((arg: any) => {\n            return hash(arg);\n          })\n          .join('_');\n      const cachedValue = cache.get(argsHash);\n      if (cachedValue !== undefined) {\n        return cachedValue;\n      }\n\n      const result = value.apply(this, args);\n      Caches.setCacheValue(this, propertyKey, argsHash, result);\n      return result;\n    };\n\n    CACHE_ANNOTATIONS.forCtor(target.constructor).attachValueToProperty(propertyKey, {});\n\n    return descriptor;\n  };\n}\n","import { Annotations } from '../data/annotations';\nimport { ImmutableMap } from '../immutable/immutable-map';\n\nconst __CACHES = Symbol('caches');\n\nexport const CACHE_ANNOTATIONS = Annotations.of(__CACHES);\n\n\nexport class Caches {\n  /**\n   * @param target Object to clear the cache from.\n   * @param propertyKey Key of the property whose cache should be cleared.\n   */\n  static clear(instance: Object, propertyKey: string | symbol): void {\n    Caches.getCache_(instance, propertyKey).clear();\n  }\n\n  /**\n   * Clears all cache in the given object.\n   * @param target Object to clear all the cache from.\n   */\n  static clearAll(instance: Object): void {\n    for (const key of CACHE_ANNOTATIONS.forCtor(instance.constructor).getAnnotatedProperties()) {\n      Caches.clear(instance, key);\n    }\n  }\n\n  /**\n   * @param target Object to get the cache of.\n   * @param propertyKey Key of the property whose cache should be retrieved.\n   */\n  static getCache(instance: Object, propertyKey: string | symbol): ImmutableMap<string, any> {\n    return ImmutableMap.of(Caches.getCache_(instance, propertyKey));\n  }\n\n  private static getCache_(instance: Object, propertyKey: string | symbol): Map<string, any> {\n    const caches = Caches.getCaches(instance);\n    const value = caches.get(propertyKey);\n    if (value !== undefined) {\n      return value;\n    }\n\n    const cache = new Map<string, any>();\n    caches.set(propertyKey, cache);\n    return cache;\n  }\n\n  private static getCaches(target: Object): Map<string | symbol, Map<string, any>> {\n    if (target[__CACHES] !== undefined) {\n      return target[__CACHES];\n    } else {\n      const caches = new Map<string | symbol, Map<string, any>>();\n      target[__CACHES] = caches;\n      return caches;\n    }\n  }\n\n  static setCacheValue(\n      instance: Object,\n      propertyKey: string | symbol,\n      key: string,\n      value: any): void {\n    Caches.getCache_(instance, propertyKey).set(key, value);\n  }\n}\n","export { Annotations } from './annotations';\nexport { Field, Serializable, Serializer } from './a-serializable';\nexport { cache } from './cache';\nexport { Jsons } from './jsons';\n","/**\n * Various utility methods to work with JSONs.\n *\n * @TODO Turn this into Fluent\n */\nimport { Errors } from '../error';\nimport { deprecated } from '../typescript/deprecated';\nimport { Log } from '../util/log';\n\nconst LOG = Log.of('gs-tools.data.Jsons');\n\nexport class Jsons {\n  static clone<T extends gs.IJson>(original: gs.IJson): T {\n    const clone = {};\n    for (const key in original) {\n      clone[key] = original[key];\n    }\n    return clone as T;\n  }\n\n  /**\n   * Recursively clones the given JSON.\n   *\n   * @param original The JSON to be cloned.\n   * @return The cloned JSON.\n   */\n  static deepClone(original: gs.IJson): gs.IJson {\n    return JSON.parse(JSON.stringify(original));\n  }\n\n  /**\n   * Searchs for the value in the JSON at the given path.\n   *\n   * @param json The object to get the value of.\n   * @param path `.` separatedpath to the location of the value to obtain.\n   * @return The value at the given location, or undefined if none exists.\n   */\n  static getValue(json: gs.IJson, path: string): any {\n    const parts = path.split('.');\n    let object = json;\n    for (let i = 0; i < parts.length && !!object; i++) {\n      object = object[parts[i]];\n    }\n    return object;\n  }\n\n  /**\n   * Mixins the two given JSONs.\n   *\n   * This will deep clone any objects in the fromObj. This will also overwrites any keys in the\n   * toObj with the value in fromObj.\n   *\n   * @param fromObj The source object to do the mixin.\n   * @param toObj The destination of the mixin.\n   * @param {gs.IJson } fromObj [description]\n   * @param {gs.IJson} toObj [description]\n   */\n  @deprecated(LOG, 'Use object spread instead')\n  static mixin<A extends gs.IJson, B extends gs.IJson>(fromObj: A, toObj: B): A & B {\n    for (const key in fromObj) {\n      const value = fromObj[key];\n      if (toObj[key] !== undefined) {\n        if (typeof toObj[key] === 'object') {\n          this.mixin(value as any, toObj[key] as any);\n        }\n      } else {\n        toObj[key] = this.deepClone(value as any) as any;\n      }\n    }\n    return toObj as A & B;\n  }\n\n  /**\n   * Sets the value of the given object at the given path.\n   *\n   * For example:\n   *\n   * ```typescript\n   * import Jsons from './jsons';\n   *\n   * Jsons.setValue(window, 'a.b.c', 123);\n   * expect(window.a.b.c).toEqual(123);\n   * ```\n   *\n   * @param json The object to set the value of.\n   * @param path `.` separated path to the location of the value to set.\n   * @param value The value to set.\n   */\n  static setValue(json: gs.IJson, path: string, value: any): void {\n    if (path === '') {\n      throw Errors.assert('path').should('not be empty').butWas(path);\n    }\n\n    let object = json;\n    const parts = path.split('.');\n    const propertyName: string = parts.pop()!;\n\n    parts.forEach((part: string) => {\n      if (object[part] === undefined) {\n        object[part] = {};\n      }\n      object = object[part];\n    });\n\n    object[propertyName] = value;\n  }\n}\n","/**\n * Contains undisposed objects.\n */\nimport { Disposable } from '../interfaces/disposable';\n\nexport const TRACKED_DISPOSABLES: BaseDisposable[] = [];\n\n/**\n * Flags to control the behavior of [[BaseDisposable]].\n */\nexport const Flags = {\n  /**\n   * Set to true to keep track of undisposed objects. This is used mainly for testing.\n   */\n  enableTracking: false,\n};\n\n/**\n * Base class of all disposable objects.\n */\nexport class BaseDisposable implements Disposable {\n  private disposables_: Disposable[];\n  private isDisposed_: boolean;\n\n  constructor() {\n    this.disposables_ = [];\n    this.isDisposed_ = false;\n    if (Flags.enableTracking) {\n      TRACKED_DISPOSABLES.push(this);\n    }\n  }\n\n  /**\n   * Adds the given disposable so they are disposed when this object is disposed.\n   *\n   * @param disposables Disposable objects to be disposed when this object is disposed.\n   */\n  addDisposable(...disposables: Disposable[]): void {\n    disposables.forEach((disposable: Disposable) => {\n      this.disposables_.push(disposable);\n    });\n  }\n\n  /**\n   * Dispose this object.\n   */\n  dispose(): void {\n    if (this.isDisposed_) {\n      return;\n    }\n\n    this.disposeInternal();\n    this.disposables_.forEach((disposable: Disposable) => disposable.dispose());\n\n    if (Flags.enableTracking) {\n      const index = TRACKED_DISPOSABLES.indexOf(this);\n      if (index >= 0) {\n        TRACKED_DISPOSABLES.splice(index, 1);\n      }\n    }\n\n    this.isDisposed_ = true;\n  }\n\n  /**\n   * Override this method for custom logic that are ran during disposal.\n   */\n  protected disposeInternal(): void { /* noop */ }\n\n  /**\n   * True iff the object has been disposed.\n   */\n  isDisposed(): boolean {\n    return this.isDisposed_;\n  }\n}\n// TODO: Mutable\n","import { BaseDisposable } from '../dispose/base-disposable';\nimport { DisposableFunction as IDisposableFunction } from '../interfaces/disposable-function';\n\n/**\n * Wrapper around a function that executes the function when this object is disposed.\n */\nexport class DisposableFunction extends BaseDisposable implements IDisposableFunction {\n  private fn_: Function;\n\n  /**\n   * @param fn Function to execute when this object is disposed.\n   */\n  constructor(fn: () => void) {\n    super();\n    this.fn_ = fn;\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal(): void {\n    this.run();\n  }\n\n  /**\n   * Runs the inner function.\n   */\n  run(): void {\n    this.fn_();\n  }\n\n  static of(fn: () => void): DisposableFunction {\n    return new DisposableFunction(fn);\n  }\n}\n","export { BaseDisposable } from './base-disposable';\nexport { DisposableFunction } from './disposable-function';\n","import { Type } from '../check';\n\nexport class AssertionShouldBuilder {\n  constructor(\n      private readonly fieldName_: string,\n      private readonly condition_: string) { }\n\n  butNot(): AssertionError {\n    return this.createAssertionError_('not');\n  }\n\n  butWas(actual: any): AssertionError {\n    return this.createAssertionError_(`was [${actual}]`);\n  }\n\n  private createAssertionError_(but: string): AssertionError {\n    return new AssertionError(\n        `[${this.fieldName_}] should ${this.condition_}, but ${but}`);\n  }\n}\n\nexport class AssertionBuilder {\n  constructor(private readonly fieldName_: string) { }\n\n  should(condition: string): AssertionShouldBuilder {\n    return new AssertionShouldBuilder(this.fieldName_, condition);\n  }\n\n  shouldBe(expected: any): AssertionShouldBuilder {\n    return this.should(`be [${expected}]`);\n  }\n\n  shouldBeA(type: Type<any>): AssertionShouldBuilder {\n    return this.should(`be a [${type}]`);\n  }\n\n  shouldBeAnInstanceOf(expected: gs.ICtor<Object>): AssertionShouldBuilder {\n    return this.should(`be an instance of [${expected.name}]`);\n  }\n\n  shouldExist(): AssertionShouldBuilder {\n    return this.should('exist');\n  }\n}\n\nexport class AssertionError extends Error {\n  constructor(message: string) {\n    super(`AssertionError: ${message}`);\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n","import { AssertionBuilder } from '../error/assertion-error';\n\nexport const Errors = {\n  assert(fieldName: string): AssertionBuilder {\n    return new AssertionBuilder(fieldName);\n  },\n};\n","export { Errors } from './errors';\n","import { Jsons } from '../data';\nimport { Errors } from '../error';\nimport { Graph } from '../graph/graph';\nimport { NodeId } from '../graph/node-id';\nimport { ImmutableList, ImmutableMap } from '../immutable';\n\nclass DebugNode<T> {\n  constructor(\n      readonly id: NodeId<T>,\n      readonly values: ImmutableMap<number, T>,\n      readonly parameters: ImmutableList<DebugNode<T>>) { }\n}\n\nexport const Debug = {\n  trace<T>(id: NodeId<T>, context: {}): DebugNode<T> {\n    const node = Graph.getNode_(id);\n    if (!node) {\n      throw Errors.assert(`Node for [${id}]`).shouldExist().butWas(node);\n    }\n\n    const valueMap = new Map();\n    for (const [time, value] of node.getCache_(context)) {\n      valueMap.set(time.value_(), value);\n    }\n\n    const parameters = node.getParameterIds()\n        .map((id: NodeId<any>) => {\n          return Debug.trace(id, context);\n        });\n    return new DebugNode<T>(id, ImmutableMap.of(valueMap), parameters);\n  },\n};\n\nJsons.setValue(window, 'gs.tools.Graph.Debug', Debug);\n","export const FLAGS = {\n  checkValueType: true,\n};\n","import { BaseDisposable } from '../dispose';\nimport { Errors } from '../error';\nimport { GraphTime } from '../graph/graph-time';\nimport { NodeId } from '../graph/node-id';\nimport { ImmutableList, ImmutableMap } from '../immutable';\n\nexport const GLOBALS = new BaseDisposable();\n\nexport abstract class GNode<T> {\n  private readonly cacheMap_: Map<{}, Map<GraphTime, T>> = new Map<{}, Map<GraphTime, T>>();\n\n  constructor(private readonly parameterIds_: ImmutableList<NodeId<any>>) { }\n\n  protected addToCache_(context: {}, timestamp: GraphTime, value: T): void {\n    const cache = this.getCache_(context);\n    if (cache.has(timestamp)) {\n      throw Errors.assert(`cache`).should(`have timestamp ${timestamp}`).butWas(cache);\n    }\n    cache.set(timestamp, value);\n  }\n\n  execute(context: {} | null, params: Iterable<any>, timestamp: GraphTime): T {\n    const normalizedContext = context || GLOBALS;\n    const cachedValue = this.getCache_(normalizedContext).get(timestamp);\n    if (cachedValue !== undefined) {\n      return cachedValue;\n    }\n\n    const value = this.execute_(normalizedContext, params);\n    this.addToCache_(normalizedContext, timestamp, value);\n    return value;\n  }\n\n  protected abstract execute_(context: {}, params: Iterable<any>): T;\n\n  getCache_(context: {}): Map<GraphTime, T> {\n    const map = this.cacheMap_.get(context);\n    if (map) {\n      return map;\n    }\n\n    const cache = new Map<GraphTime, T>();\n    this.cacheMap_.set(context, cache);\n    return cache;\n  }\n\n  getLatestCacheValue(context: {} | null, timestamp: GraphTime): [GraphTime, T] | null {\n    const cache = this.cacheMap_.get(context || GLOBALS);\n    if (!cache) {\n      return null;\n    }\n\n    return ImmutableMap\n        .of(cache)\n        .filter((_: T, time: GraphTime) => {\n          return time.beforeOrEqualTo(timestamp);\n        })\n        .reduce<[GraphTime, T] | null>(\n            (\n                prev: [GraphTime, T] | null,\n                value: T,\n                key: GraphTime) => {\n              if (!prev) {\n                return [key, value];\n              }\n\n              if (prev[0].beforeOrEqualTo(key)) {\n                return [key, value];\n              } else {\n                return prev;\n              }\n            },\n            null);\n  }\n\n  getParameterIds(): ImmutableList<NodeId<any>> {\n    return this.parameterIds_;\n  }\n}\n","import { BaseDisposable, DisposableFunction } from '../dispose';\nimport { GLOBALS } from '../graph/g-node';\nimport { GraphEvent } from '../graph/graph-event';\nimport { InstanceId } from '../graph/instance-id';\nimport { NodeId } from '../graph/node-id';\nimport { StaticId } from '../graph/static-id';\n\ntype Handler<T, C> = (event: GraphEvent<T, C>) => any;\n\nexport class GraphEventHandler extends BaseDisposable {\n  private readonly onChangeListeners_: WeakMap<{}, Map<NodeId<any>, Set<Handler<any, any>>>>\n      = new WeakMap();\n  private readonly onReadyListeners_: WeakMap<{}, Map<NodeId<any>, Set<Handler<any, any>>>>\n      = new WeakMap();\n\n  private callHandlers_(\n      listeners: WeakMap<{}, Map<NodeId<any>, Set<Handler<any, any>>>>,\n      context: {},\n      id: NodeId<any>,\n      type: 'change' | 'ready'): void {\n    const handlers = this.getHandlers_(listeners, context, id) || new Set<Handler<any, any>>();\n    const event = {context, id, type};\n    for (const handler of handlers) {\n      handler(event);\n    }\n  }\n\n  dispatchChange(id: StaticId<any>): void;\n  dispatchChange(id: InstanceId<any>, context: {}): void;\n  dispatchChange(id: NodeId<any>, context: {} = GLOBALS): void {\n    this.callHandlers_(this.onChangeListeners_, context, id, 'change');\n  }\n\n  dispatchReady(id: StaticId<any>): void;\n  dispatchReady(id: InstanceId<any>, context: {}): void;\n  dispatchReady(id: NodeId<any>, context: {} = GLOBALS): void {\n    this.callHandlers_(this.onReadyListeners_, context, id, 'ready');\n  }\n\n  private getHandlers_(\n      listeners: WeakMap<{}, Map<NodeId<any>, Set<Handler<any, any>>>>,\n      context: {},\n      id: NodeId<any>): Set<Handler<any, any>> | null {\n    const map = listeners.get(context);\n    if (!map) {\n      return null;\n    }\n\n    return map.get(id) || null;\n  }\n\n  private modifyHandlers_(\n      listeners: WeakMap<{}, Map<NodeId<any>, Set<Handler<any, any>>>>,\n      context: {},\n      id: NodeId<any>,\n      fn: (handlers: Set<Handler<any, any>>) => void): void {\n    const map = listeners.get(context) || new Map<NodeId<any>, Set<Handler<any, any>>>();\n    const handlers = map.get(id) || new Set();\n    fn(handlers);\n\n    if (handlers.size > 0) {\n      map.set(id, handlers);\n    } else {\n      map.delete(id);\n    }\n\n    if (map.size > 0) {\n      listeners.set(context, map);\n    } else {\n      listeners.delete(context);\n    }\n  }\n\n  onChange<C>(id: StaticId<any>, handler: Handler<any, C>): DisposableFunction;\n  onChange<C>(id: InstanceId<any>, handler: Handler<any, C>, context: C): DisposableFunction;\n  onChange(id: NodeId<any>, handler: Handler<any, any>, context: {} = GLOBALS): DisposableFunction {\n    this.modifyHandlers_(this.onChangeListeners_, context, id, (handlers) => handlers.add(handler));\n\n    return DisposableFunction.of(() => {\n      this.modifyHandlers_(\n          this.onChangeListeners_,\n          context,\n          id,\n          (handlers) => handlers.delete(handler));\n    });\n  }\n\n  onReady<C>(id: StaticId<any>, handler: Handler<any, C>): DisposableFunction;\n  onReady<C>(id: InstanceId<any>, handler: Handler<any, C>, context: C): DisposableFunction;\n  onReady(id: NodeId<any>, handler: Handler<any, any>, context: {} = GLOBALS): DisposableFunction {\n    this.modifyHandlers_(this.onReadyListeners_, context, id, (handlers) => handlers.add(handler));\n\n    return DisposableFunction.of(() => {\n      this.modifyHandlers_(\n          this.onReadyListeners_,\n          context,\n          id,\n          (handlers) => handlers.delete(handler));\n    });\n  }\n}\n","import { GNode } from '../graph/g-node';\nimport { GraphTime } from '../graph/graph-time';\nimport { ImmutableList } from '../immutable';\n\nexport class GraphTimeNode extends GNode<GraphTime> {\n  constructor() {\n    super(ImmutableList.of([]));\n  }\n\n  execute(_context: {} | null, _params: Iterable<any>, timestamp: GraphTime): GraphTime {\n    return timestamp;\n  }\n\n  protected execute_(): GraphTime {\n    throw new Error('Method not implemented.');\n  }\n}\n","import { InstanceofType } from '../check';\nimport { staticId } from '../graph/static-id';\n\nexport class GraphTime {\n  constructor(private readonly timestamp_: number) { }\n\n  before(other: GraphTime): boolean {\n    return this.timestamp_ < other.timestamp_;\n  }\n\n  beforeOrEqualTo(other: GraphTime): boolean {\n    return this.timestamp_ <= other.timestamp_;\n  }\n\n  /**\n   * Increments the time. This guarantees that the new time is greater than the previous one but\n   * does not guarantee equality with other times. E.g.: time.increment() and time.increment() may\n   * be different.\n   */\n  increment(): GraphTime {\n    return new GraphTime(this.timestamp_ + 1);\n  }\n\n  toString(): string {\n    return `GraphTime(${this.timestamp_})`;\n  }\n\n  value_(): number {\n    return this.timestamp_;\n  }\n\n  /**\n   * Creates a new timestamp. This does not guarantee that two graph times are the same. E.g.\n   * GraphTime.new() and GraphTime.new() may have different timestamps.\n   */\n  static new(): GraphTime {\n    return new GraphTime(0);\n  }\n}\n\nexport const $time = staticId('time', InstanceofType(GraphTime));\n","import { BaseDisposable, DisposableFunction } from '../dispose';\nimport { Errors } from '../error';\nimport { FLAGS } from '../graph/flags';\nimport { GLOBALS, GNode } from '../graph/g-node';\nimport { GraphEvent } from '../graph/graph-event';\nimport { GraphEventHandler } from '../graph/graph-event-handler';\nimport { $time, GraphTime } from '../graph/graph-time';\nimport { GraphTimeNode } from '../graph/graph-time-node';\nimport { InnerNode } from '../graph/inner-node';\nimport { InputNode } from '../graph/input-node';\nimport { InstanceId } from '../graph/instance-id';\nimport { NodeId } from '../graph/node-id';\nimport { InstanceNodeProvider, StaticNodeProvider } from '../graph/node-provider';\nimport { Provider, Provider0, Provider1, Provider2, Provider3 } from '../graph/provider';\nimport { StaticId } from '../graph/static-id';\nimport { ImmutableList, ImmutableSet } from '../immutable';\nimport { equals } from '../typescript';\nimport { Log } from '../util';\n\nconst LOGGER: Log = Log.of('gs-tools.graph.Graph');\n\nexport class GraphImpl extends BaseDisposable {\n  private currentTime_: GraphTime = GraphTime.new();\n  private readonly eventHandler_: GraphEventHandler;\n  private readonly monitoredNodes_: WeakMap<{}, ImmutableSet<NodeId<any>>> = new WeakMap();\n  private readonly nodes_: Map<NodeId<any>, GNode<any>> = new Map([[$time, new GraphTimeNode()]]);\n  private readonly setQueue_: (() => void)[] = [];\n  private readonly transitiveDependencies_: Map<NodeId<any>, ImmutableSet<NodeId<any>>> = new Map();\n\n  constructor() {\n    super();\n    this.eventHandler_ = new GraphEventHandler();\n    this.addDisposable(this.eventHandler_);\n  }\n\n  private assertNodeExist_(nodeId: NodeId<any>): void {\n    this.getNode_(nodeId);\n  }\n\n  /**\n   * Creates a new provider.\n   * @param staticId\n   * @param initValue\n   * @return Function to call for setting the value. The return value of this is a Promise that will\n   *     be resolved when the value has been set.\n   */\n  createProvider<T>(staticId: StaticId<T>, initValue: T): StaticNodeProvider<T>;\n  createProvider<T>(instanceId: InstanceId<T>, initValue: T): InstanceNodeProvider<T>;\n  createProvider<T>(nodeId: NodeId<T>, initValue: T):\n      StaticNodeProvider<T> | InstanceNodeProvider<T> {\n    if (this.nodes_.has(nodeId)) {\n      throw new Error(`Node ${nodeId} is already registered`);\n    }\n\n    const node = new InputNode<T>(initValue);\n    this.nodes_.set(nodeId, node);\n\n    if (nodeId instanceof StaticId) {\n      return (newValue: T): Promise<void> => this.set_(nodeId, GLOBALS, newValue);\n    } else {\n      return (newValue: T, context: {}): Promise<void> => this.set_(nodeId, context, newValue);\n    }\n  }\n\n  /**\n   * Gets the value associated with the given ID.\n   * @param staticId\n   * @return Promise that will be resolved with the value associated with the given ID.\n   */\n  async get<T>(staticId: StaticId<T>, timestamp: GraphTime): Promise<T>;\n  async get<T, C extends BaseDisposable>(\n      instanceId: InstanceId<T>, timestamp: GraphTime, context: C): Promise<T>;\n  async get<T>(\n      nodeId: NodeId<T>, timestamp: GraphTime, context: BaseDisposable = GLOBALS): Promise<T> {\n    // TODO: This needs a ticketing system.\n    Log.debug(LOGGER, `getting: ${nodeId}`);\n\n    const idealExecutionTime = nodeId instanceof StaticId ?\n        this.getIdealExecutionTime_(nodeId, timestamp) :\n        this.getIdealExecutionTime_(nodeId, timestamp, context);\n\n    const node = this.getNode_(nodeId);\n    const latestCacheValue = node.getLatestCacheValue(context, idealExecutionTime);\n\n    const parameters = await Promise.all(node.getParameterIds()\n        .map((parameterId: NodeId<any>) => {\n          if (parameterId instanceof StaticId) {\n            return this.get(parameterId, idealExecutionTime);\n          } else {\n            return this.get(parameterId, idealExecutionTime, context);\n          }\n        }));\n\n    if (node instanceof InnerNode &&\n        !this.isMonitored_(context, nodeId)) {\n      for (const dependencyId of this.getTransitiveDependencies_(nodeId)) {\n        const handler = () => this.onReady_<T, any>(nodeId, context);\n        if (dependencyId instanceof StaticId) {\n          this.addDisposable(this.eventHandler_.onReady(dependencyId, handler));\n        } else {\n          this.addDisposable(this.eventHandler_.onReady(dependencyId, handler, context));\n        }\n      }\n      const ids = this.monitoredNodes_.get(context) || ImmutableSet.of([]);\n      this.monitoredNodes_.set(context, ids.add(nodeId));\n    }\n\n    Log.debug(LOGGER, `executing: ${nodeId}`);\n    const value = node.execute(context, parameters, idealExecutionTime);\n\n    const cachedValue = latestCacheValue ? latestCacheValue[1] : null;\n    const [resolvedCached, resolvedValue] = await Promise.all([cachedValue, value]);\n    if (FLAGS.checkValueType && !nodeId.getType().check(resolvedValue)) {\n      throw new Error(`Node for ${nodeId} returns the incorrect type. [${resolvedValue}]`);\n    }\n\n    if (!equals(resolvedCached, resolvedValue)) {\n      if (nodeId instanceof InstanceId) {\n        this.eventHandler_.dispatchChange(nodeId, context);\n      } else {\n        this.eventHandler_.dispatchChange(nodeId);\n      }\n    }\n\n    Log.debug(LOGGER, `executed: ${nodeId} ${resolvedValue}`);\n    return resolvedValue;\n  }\n\n  async getAll<T0>(\n      timestamp: GraphTime,\n      context: BaseDisposable,\n      nodeId: NodeId<T0>): Promise<[T0]>;\n  async getAll<T0, T1>(\n      timestamp: GraphTime,\n      context: BaseDisposable,\n      nodeId0: NodeId<T0>,\n      nodeId1: NodeId<T1>): Promise<[T0, T1]>;\n  async getAll<T0, T1, T2>(\n      timestamp: GraphTime,\n      context: BaseDisposable,\n      nodeId0: NodeId<T0>,\n      nodeId1: NodeId<T1>,\n      nodeId2: NodeId<T2>): Promise<[T0, T1, T2]>;\n  async getAll(\n      timestamp: GraphTime, context: BaseDisposable, ...nodeIds: NodeId<any>[]): Promise<any[]> {\n    return Promise.all(nodeIds.map((nodeId) => {\n      if (nodeId instanceof StaticId) {\n        return this.get(nodeId, timestamp);\n      } else {\n        return this.get(nodeId, timestamp, context);\n      }\n    }));\n  }\n\n  private getIdealExecutionTime_(staticId: StaticId<any>, timestamp: GraphTime): GraphTime;\n  private getIdealExecutionTime_(instanceId: InstanceId<any>, timestamp: GraphTime, context: {}):\n      GraphTime;\n  private getIdealExecutionTime_(\n      nodeId: NodeId<any>,\n      timestamp: GraphTime,\n      context: {} = GLOBALS): GraphTime {\n    const node = this.getNode_(nodeId);\n    const parameterIds = node.getParameterIds();\n    if (parameterIds.size() === 0) {\n      const entry = node.getLatestCacheValue(context, timestamp);\n      return entry ? entry[0] : this.currentTime_;\n    }\n    const times = parameterIds\n        .map((id: NodeId<any>) => {\n          if (id instanceof StaticId) {\n            return this.getIdealExecutionTime_(id, timestamp);\n          } else {\n            return this.getIdealExecutionTime_(id, timestamp, context);\n          }\n        });\n    return times.reduce((prev: GraphTime, current: GraphTime) => {\n          return prev.beforeOrEqualTo(current) ? current : prev;\n        },\n        times.getAt(0)!);\n  }\n\n  getNode_<T>(nodeId: NodeId<T>): GNode<T> {\n    const node = this.nodes_.get(nodeId);\n    if (!node) {\n      throw Errors.assert(`Node [${nodeId}]`).shouldExist().butWas(node);\n    }\n\n    return node;\n  }\n\n  getTimestamp(): GraphTime {\n    return this.currentTime_;\n  }\n\n  private getTransitiveDependencies_(nodeId: NodeId<any>): ImmutableSet<NodeId<any>> {\n    const existingDependencies = this.transitiveDependencies_.get(nodeId);\n    if (existingDependencies) {\n      return existingDependencies;\n    }\n\n    const node = this.nodes_.get(nodeId);\n    if (!node) {\n      throw Errors.assert(`Node for [${nodeId}]`).shouldExist().butNot();\n    }\n\n    const dependencies: Set<NodeId<any>> = new Set();\n    for (const paramId of node.getParameterIds()) {\n      dependencies.add(paramId);\n      for (const dependency of this.getTransitiveDependencies_(paramId)) {\n        dependencies.add(dependency);\n      }\n    }\n    const deps = ImmutableSet.of(dependencies);\n    this.transitiveDependencies_.set(nodeId, deps);\n    return deps;\n  }\n\n  private isMonitored_(context: {}, nodeId: NodeId<any>): boolean {\n    const ids = this.monitoredNodes_.get(context);\n    if (!ids) {\n      return false;\n    }\n\n    return ids.has(nodeId);\n  }\n\n  isRegistered(id: NodeId<any>): boolean {\n    return this.nodes_.has(id);\n  }\n\n  onChange<C>(\n      id: InstanceId<any>,\n      handler: (event: GraphEvent<any, C>) => any,\n      context: C): DisposableFunction;\n  onChange<C>(id: StaticId<any>, handler: (event: GraphEvent<any, C>) => any): DisposableFunction;\n  onChange<C>(id: NodeId<any>, handler: (event: GraphEvent<any, C>) => any, context?: C):\n      DisposableFunction {\n    if (id instanceof StaticId) {\n      return this.eventHandler_.onChange<C>(id, handler);\n    } else {\n      return this.eventHandler_.onChange<C>(id, handler, context!);\n    }\n  }\n\n  onReady<C>(context: C, id: NodeId<any>, handler: (event: GraphEvent<any, C>) => any):\n      DisposableFunction {\n    if (id instanceof StaticId) {\n      return this.eventHandler_.onReady<C>(id, handler);\n    } else {\n      return this.eventHandler_.onReady<C>(id, handler, context);\n    }\n  }\n\n  private onReady_<T, C>(nodeId: NodeId<T>, context: C): void {\n    if (nodeId instanceof StaticId) {\n      this.refresh(nodeId);\n    } else {\n      this.refresh(nodeId, context);\n    }\n  }\n\n  private async processSetQueue_(): Promise<void> {\n    const promises = this.setQueue_.map((setFn) => new Promise((resolve) => {\n      window.setTimeout(() => {\n        setFn();\n        resolve();\n      }, 0);\n    }));\n    this.setQueue_.splice(0, this.setQueue_.length);\n    await Promise.all(promises);\n  }\n\n  refresh<T>(staticId: StaticId<T>): void;\n  refresh<T, C>(instanceId: InstanceId<T>, context: C): void;\n  refresh<T>(nodeId: StaticId<T> | InstanceId<T>, context: {} = GLOBALS): void {\n    this.assertNodeExist_(nodeId);\n    if (nodeId instanceof StaticId) {\n      this.eventHandler_.dispatchReady(nodeId);\n    } else {\n      this.eventHandler_.dispatchReady(nodeId, context);\n    }\n  }\n\n  registerGenericProvider_<T>(\n      nodeId: NodeId<T>,\n      provider: Provider<T>,\n      ...args: NodeId<any>[]): void {\n    const existingNode = this.nodes_.get(nodeId);\n    if (existingNode) {\n      if (!(existingNode instanceof InnerNode)) {\n        throw Errors.assert(`Node for [${nodeId}]`).should('not be registered').butNot();\n      }\n\n      if (existingNode.getProvider().toString() !== provider.toString()) {\n        throw Errors\n            .assert(`reregistered node provider for ${nodeId}`)\n            .shouldBe(existingNode.getProvider())\n            .butWas(provider);\n      }\n\n      const existingArgs = existingNode.getParameterIds();\n      const newArgs = ImmutableList.of(args);\n      const maxIndex = Math.max(existingArgs.size(), newArgs.size());\n      for (let i = 0; i < maxIndex; i++) {\n        const existingArg = existingArgs.getAt(i);\n        const newArg = newArgs.getAt(i);\n        if (existingArg !== newArg) {\n          throw Errors\n              .assert(`reregistered node parameter ${i} for ${nodeId}`)\n              .shouldBe(existingArg)\n              .butNot();\n        }\n      }\n      return;\n    }\n\n    const node = new InnerNode<T>(provider, ImmutableList.of(args));\n    this.nodes_.set(nodeId, node);\n  }\n\n  /**\n   * Registers the given provider function.\n   * @param nodeId\n   * @param provider\n   */\n  registerProvider<T>(\n      nodeId: NodeId<T>,\n      provider: Provider0<T>): void;\n\n  registerProvider<T, P0>(\n      staticId: StaticId<T>,\n      provider: Provider1<T, P0>,\n      arg0: StaticId<P0>): void;\n  registerProvider<T, P0, P1>(\n      staticId: StaticId<T>,\n      provider: Provider2<T, P0, P1>,\n      arg0: StaticId<P0>,\n      arg1: StaticId<P1>): void;\n  registerProvider<T, P0, P1, P2>(\n      staticId: StaticId<T>,\n      provider: Provider3<T, P0, P1, P2>,\n      arg0: StaticId<P0>,\n      arg1: StaticId<P1>,\n      arg2: StaticId<P2>): void;\n\n  registerProvider<T, P0>(\n      instanceId: InstanceId<T>,\n      provider: Provider1<T, P0>,\n      arg0: NodeId<P0>): void;\n  registerProvider<T, P0, P1>(\n      instanceId: InstanceId<T>,\n      provider: Provider2<T, P0, P1>,\n      arg0: NodeId<P0>,\n      arg1: NodeId<P1>): void;\n  registerProvider<T, P0, P1, P2>(\n      instanceId: InstanceId<T>,\n      provider: Provider3<T, P0, P1, P2>,\n      arg0: NodeId<P0>,\n      arg1: NodeId<P1>,\n      arg2: NodeId<P2>): void;\n\n  registerProvider<T>(\n      nodeId: NodeId<T>,\n      provider: Provider<T>,\n      ...args: NodeId<any>[]): void {\n    this.registerGenericProvider_(nodeId, provider, ...args);\n  }\n\n  private set_<T>(nodeId: NodeId<T>, context: {}, value: T): Promise<void> {\n    Log.debug(LOGGER, `setting: ${nodeId} ${value}`);\n\n    const node = this.nodes_.get(nodeId);\n    if (!(node instanceof InputNode)) {\n      throw Errors.assert(`Node ${nodeId}`).shouldBeAnInstanceOf(InputNode).butWas(node);\n    }\n\n    const promise = new Promise<void>((resolve: () => void) => {\n      this.setQueue_.push(() => {\n        Log.debug(LOGGER, `set flush: ${nodeId} ${value}`);\n        const newTime = this.currentTime_.increment();\n        node.set(context, newTime, value);\n        this.currentTime_ = newTime;\n        if (nodeId instanceof StaticId) {\n          this.refresh(nodeId);\n          this.eventHandler_.dispatchChange(nodeId);\n        } else {\n          this.refresh(nodeId, context);\n          this.eventHandler_.dispatchChange(nodeId, context);\n        }\n        resolve();\n      });\n    });\n\n    setTimeout(() => this.processSetQueue_(), 0);\n\n    return promise;\n  }\n\n  toString(): string {\n    return 'Graph';\n  }\n}\n\nexport const Graph = new GraphImpl();\n","export { Debug } from './debug';\nexport { FLAGS } from './flags';\nexport { Graph } from './graph';\nexport { GraphEvent } from './graph-event';\nexport { $time, GraphTime } from './graph-time';\nexport { InstanceNodeProvider, StaticNodeProvider } from './node-provider';\nexport { instanceId, InstanceId } from './instance-id';\nexport { NodeId } from './node-id';\nexport { nodeIn } from './node-in';\nexport { nodeOut } from './node-out';\nexport { staticId, StaticId } from './static-id';\nexport { TestGraph } from './test-graph';\n","import { GNode } from '../graph/g-node';\nimport { NodeId } from '../graph/node-id';\nimport { Provider } from '../graph/provider';\nimport { ImmutableList } from '../immutable';\n\nexport class InnerNode<T> extends GNode<T> {\n  constructor(\n      private readonly fn_: Provider<T>,\n      parameterIds_: ImmutableList<NodeId<any>>) {\n    super(parameterIds_);\n  }\n\n  execute_(context: {}, params: Iterable<any>): T {\n    return this.fn_.apply(context, [...params]);\n  }\n\n  getProvider(): Provider<T> {\n    return this.fn_;\n  }\n}\n","import { GLOBALS, GNode } from '../graph/g-node';\nimport { GraphTime } from '../graph/graph-time';\nimport { ImmutableList } from '../immutable';\n\nexport class InputNode<T> extends GNode<T> {\n  private readonly symbol_: symbol = Symbol('inputNode');\n\n  constructor(private readonly initValue_: T) {\n    super(ImmutableList.of([]));\n  }\n\n  protected execute_(context: {}): T {\n    const value = context[this.symbol_];\n    return value === undefined ? this.initValue_ : value;\n  }\n\n  set(context: {} | null, timestamp: GraphTime, value: T): void {\n    const normalizedContext = context || GLOBALS;\n    this.set_(normalizedContext, value);\n    this.addToCache_(normalizedContext, timestamp, value);\n  }\n\n  private set_(context: {}, value: T): void {\n    context[this.symbol_] = value;\n  }\n}\n","import { Type } from '../check';\n\nexport class InstanceId<T> {\n  constructor(\n      private readonly debug_: string,\n      private readonly type_: Type<T>) { }\n\n  getType(): Type<T> {\n    return this.type_;\n  }\n\n  toString(): string {\n    return `InstanceId(${this.debug_})`;\n  }\n}\n\nexport function instanceId<T>(debug: string, type: Type<T>): InstanceId<T> {\n  return new InstanceId(debug, type);\n}\n","import { Annotations } from '../data';\nimport { NodeId } from '../graph/node-id';\n\ntype Data = {id: NodeId<any>, index: number};\nexport const ANNOTATIONS: Annotations<Data> = Annotations.of<Data>(Symbol('nodeIn'));\n\nexport function nodeIn(id: NodeId<any>): ParameterDecorator {\n  return (target: Object, propertyKey: string | symbol, index: number) => {\n    ANNOTATIONS.forCtor(target.constructor)\n        .attachValueToProperty(propertyKey, {index, id});\n  };\n}\n","import { Graph } from '../graph';\nimport { InstanceId } from '../graph/instance-id';\nimport { NodeId } from '../graph/node-id';\nimport { ANNOTATIONS } from '../graph/node-in';\n\nexport function nodeOut(instanceId: InstanceId<any>): MethodDecorator {\n  return (target: Object, propertyKey: string | symbol) => {\n    const paramsSet = ANNOTATIONS\n        .forCtor(target.constructor)\n        .getAttachedValues()\n        .get(propertyKey);\n\n    const paramsArray: NodeId<any>[] = [];\n    for (const {index, id} of paramsSet || []) {\n      paramsArray[index] = id;\n    }\n\n    Graph.registerGenericProvider_(\n        instanceId,\n        target[propertyKey] as any,\n        ...paramsArray);\n  };\n}\n","import { Type } from '../check';\n\nexport class StaticId<T> {\n  constructor(\n      private readonly debug_: string,\n      private readonly type_: Type<T>) { }\n\n  getType(): Type<T> {\n    return this.type_;\n  }\n\n  toString(): string {\n    return `StaticId(${this.debug_})`;\n  }\n}\n\nexport function staticId<T>(debug: string, type: Type<T>): StaticId<T> {\n  return new StaticId(debug, type);\n}\n","import { FLAGS } from '../graph/flags';\nimport { Graph } from '../graph/graph';\nimport { NodeId } from '../graph/node-id';\nimport { StaticId } from '../graph/static-id';\n\nconst originalMap = new Map();\nlet originalCheckValueType: boolean = false;\n\nexport const TestGraph = {\n  afterEach(): void {\n    Graph['nodes_'].clear();\n    for (const [key, node] of originalMap) {\n      Graph['nodes_'].set(key, node);\n    }\n    FLAGS.checkValueType = originalCheckValueType;\n    Graph['setQueue_'].splice(0, Graph['setQueue_'].length);\n\n    for (const disposable of Graph['disposables_']) {\n      disposable.dispose();\n    }\n  },\n\n  beforeEach(): void {\n    originalCheckValueType = FLAGS.checkValueType;\n    originalMap.clear();\n    for (const [key, node] of Graph['nodes_']) {\n      originalMap.set(key, node);\n    }\n  },\n\n  clear(...nodeIds: NodeId<any>[]): void {\n    for (const nodeId of nodeIds) {\n      Graph['nodes_'].delete(nodeId);\n    }\n  },\n\n  init(): void { },\n\n  set<T>(nodeId: NodeId<T>, initValue: T): void {\n    FLAGS.checkValueType = false;\n    TestGraph.clear(nodeId);\n    if (nodeId instanceof StaticId) {\n      Graph.createProvider(nodeId, initValue);\n    } else {\n      Graph.createProvider(nodeId, initValue);\n    }\n  },\n};\n","export class Generators {\n  static *ranged(\n      from: number,\n      step: number,\n      to: number): IterableIterator<number> {\n    if (from > to) {\n      throw new Error(`${from} must be <= ${to}`);\n    }\n    for (let i = from; i < to; i += step) {\n      yield i;\n    }\n  }\n}\n","import {\n  FiniteIterableType,\n  HasPropertyType,\n  InstanceofType,\n  IntersectType,\n  NumberType,\n  Type } from '../check';\nimport { Errors } from '../error';\nimport { Orderings } from '../immutable/orderings';\nimport { CompareResult, FiniteCollection, FiniteIndexed, Ordered, Ordering } from '../interfaces';\nimport { assertUnreachable } from '../typescript';\n\ntype ItemList<T> = { item: (index: number) => T, length: number };\nfunction ItemListType<T>(): Type<ItemList<T>> {\n  return IntersectType.builder<ItemList<T>>()\n      .addType(HasPropertyType('item', InstanceofType(Function)))\n      .addType(HasPropertyType('length', NumberType))\n      .build();\n}\n\nexport class ImmutableList<T> implements\n    FiniteCollection<T>,\n    FiniteIndexed<number, T>,\n    Ordered<T> {\n  private readonly data_: T[];\n\n  constructor(data: T[]) {\n    this.data_ = data.slice(0);\n  }\n\n  [Symbol.iterator](): Iterator<T> {\n    return this.data_[Symbol.iterator]();\n  }\n\n  add(item: T): ImmutableList<T> {\n    const clone = this.data_.slice(0);\n    clone.push(item);\n    return new ImmutableList(clone);\n  }\n\n  addAll(items: FiniteCollection<T>): ImmutableList<T> {\n    const clone = this.data_.slice(0);\n    for (const item of items) {\n      clone.push(item);\n    }\n    return new ImmutableList(clone);\n  }\n\n  delete(item: T): ImmutableList<T> {\n    const clone = this.data_.slice(0);\n    const index = clone.indexOf(item);\n    if (index < 0) {\n      return this;\n    } else {\n      clone.splice(index, 1);\n      return new ImmutableList(clone);\n    }\n  }\n\n  deleteAll(items: FiniteCollection<T>): ImmutableList<T> {\n    const clone = this.data_.slice(0);\n    for (const item of items) {\n      const index = clone.indexOf(item);\n      if (index >= 0) {\n        clone.splice(index, 1);\n      }\n    }\n    return new ImmutableList(clone);\n  }\n\n  deleteAllKeys(keys: FiniteCollection<number>): ImmutableList<T> {\n    const toDeleteIndexes: number[] = [];\n    for (const key of keys) {\n      toDeleteIndexes.push(key);\n    }\n    toDeleteIndexes.sort((index1: number, index2: number) => {\n      if (index1 > index2) {\n        return 1;\n      } else if (index1 < index2) {\n        return -1;\n      } else {\n        return 0;\n      }\n    });\n\n    const clone = this.data_.slice(0);\n    for (const index of toDeleteIndexes.reverse()) {\n      clone.splice(index, 1);\n    }\n    return new ImmutableList(clone);\n  }\n\n  deleteAt(index: number): ImmutableList<T> {\n    return this.deleteKey(index);\n  }\n\n  deleteKey(key: number): ImmutableList<T> {\n    const clone = this.data_.slice(0);\n    clone.splice(key, 1);\n    return new ImmutableList(clone);\n  }\n\n  entries(): ImmutableList<[number, T]> {\n    const clone = this.data_.map((value: T, index: number) => {\n      return [index, value] as [number, T];\n    });\n    return new ImmutableList(clone);\n  }\n\n  equals(other: Ordered<T>): boolean {\n    if (this.size() !== other.size()) {\n      return false;\n    }\n\n    for (let i = 0; i < this.size(); i++) {\n      if (this.getAt(i) !== other.getAt(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  every(check: (value: T, key: number) => boolean): boolean {\n    for (const [key, value] of this.entries()) {\n      if (!check(value, key)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  everyItem(check: (item: T) => boolean): boolean {\n    return this.every((value: T) => {\n      return check(value);\n    });\n  }\n\n  filter(checker: (value: T, index: number) => boolean): ImmutableList<T> {\n    return new ImmutableList(this.data_.filter(checker));\n  }\n\n  filterByType<T2>(checker: Type<T2>): ImmutableList<T2> {\n    const newItems: T2[] = [];\n    for (const item of this) {\n      if (checker.check(item)) {\n        newItems.push(item);\n      }\n    }\n    return ImmutableList.of(newItems);\n  }\n\n  filterItem(checker: (item: T) => boolean): ImmutableList<T> {\n    return this.filter((value: T, _: number) => checker(value));\n  }\n\n  find(check: (item: T) => boolean): T | null {\n    return this.findValue(check);\n  }\n\n  findEntry(checker: (value: T, index: number) => boolean): [number, T] | null {\n    for (const [index, value] of this.entries()) {\n      if (checker(value, index)) {\n        return [index, value];\n      }\n    }\n    return null;\n  }\n\n  findKey(checker: (value: T, index: number) => boolean): number | null {\n    const entry = this.findEntry(checker);\n    return entry === null ? null : entry[0];\n  }\n\n  findValue(checker: (value: T, index: number) => boolean): T | null {\n    const entry = this.findEntry(checker);\n    return entry === null ? null : entry[1];\n  }\n\n  get(index: number): T | undefined {\n    return this.data_[index];\n  }\n\n  getAt(index: number): T | undefined {\n    const normalizedIndex = index < 0 ? index + this.size() : index;\n    return this.get(normalizedIndex);\n  }\n\n  has(item: T): boolean {\n    return this.data_.indexOf(item) >= 0;\n  }\n\n  hasKey(key: number): boolean {\n    return this.data_[key] !== undefined;\n  }\n\n  insertAllAt(index: number, items: FiniteCollection<T>): ImmutableList<T> {\n    const toAdds: T[] = [];\n    for (const toAdd of items) {\n      toAdds.push(toAdd);\n    }\n    const clone = this.data_.slice(0);\n    clone.splice(index, 0, ...toAdds);\n    return new ImmutableList(clone);\n  }\n\n  insertAt(index: number, item: T): ImmutableList<T> {\n    const clone = this.data_.slice(0);\n    clone.splice(index, 0, item);\n    return new ImmutableList(clone);\n  }\n\n  keys(): ImmutableList<number> {\n    return new ImmutableList(this.data_.map((_: T, index: number) => index));\n  }\n\n  map<R>(fn: (value: T, index: number) => R): ImmutableList<R> {\n    return new ImmutableList(this.data_.map(fn));\n  }\n\n  mapItem<R>(fn: (item: T) => R): ImmutableList<R> {\n    return this.map<R>((value: T, _: number) => fn(value));\n  }\n\n  max(ordering: Ordering<T>): T | null {\n    return this.reduceItem(\n        (prevValue: T | null, value: T) => {\n          if (prevValue === null) {\n            return value;\n          }\n\n          if (ordering(prevValue, value) === -1) {\n            return value;\n          } else {\n            return prevValue;\n          }\n        },\n        null);\n  }\n\n  min(ordering: Ordering<T>): T | null {\n    return this.max(Orderings.reverse(ordering));\n  }\n\n  reduce<R>(fn: (prevValue: R, value: T, key: number) => R, init: R): R {\n    return this.data_.reduce(fn, init);\n  }\n\n  reduceItem<R>(fn: (prevItem: R, item: T) => R, init: R): R {\n    return this.reduce((prev: R, value: T) => {\n      return fn(prev, value);\n    }, init);\n  }\n\n  reverse(): ImmutableList<T> {\n    return new ImmutableList(this.data_.reverse());\n  }\n\n  set(index: number, item: T): ImmutableList<T> {\n    const clone = this.data_.slice(0);\n    clone[index] = item;\n    return new ImmutableList(clone);\n  }\n\n  setAt(index: number, item: T): ImmutableList<T> {\n    return this.set(index, item);\n  }\n\n  size(): number {\n    return this.data_.length;\n  }\n\n  slice(start?: number, end?: number, step: number = 1): ImmutableList<T> {\n    if (step === 0) {\n      throw Errors.assert('step').shouldBe('not 0').butWas(step);\n    }\n\n    let normalizedEnd;\n    if (end === undefined) {\n      normalizedEnd = step > 0 ? this.data_.length : -1;\n    } else if (end < 0) {\n      normalizedEnd = end + this.data_.length;\n    } else {\n      normalizedEnd = end;\n    }\n\n    let normalizedStart;\n    if (start !== undefined) {\n      normalizedStart = start;\n    } else if (step > 0) {\n      normalizedStart = 0;\n    } else {\n      normalizedStart = this.data_.length - 1;\n    }\n\n    const sliceData: T[] = [];\n    let loopBound;\n    if (step > 0) {\n      loopBound = Math.min(this.data_.length, normalizedEnd);\n    } else {\n      loopBound = Math.max(-1, normalizedEnd);\n    }\n    for (let i = normalizedStart; step < 0 ? i > loopBound : i < loopBound; i += step) {\n      sliceData.push(this.data_[i]);\n    }\n    return new ImmutableList(sliceData);\n  }\n\n  some(check: (value: T, key: number) => boolean): boolean {\n    for (const [key, value] of this.entries()) {\n      if (check(value, key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  someItem(check: (item: T) => boolean): boolean {\n    return this.some((value: T) => {\n      return check(value);\n    });\n  }\n\n  sort(compareFn: (item1: T, item2: T) => CompareResult): ImmutableList<T> {\n    const clone = this.data_.slice(0);\n    return new ImmutableList(clone.sort(compareFn));\n  }\n\n  toString(): string {\n    const items = this.mapItem((item: T) => `${item}`);\n    return `[${[...items].join(', ')}]`;\n  }\n\n  values(): ImmutableList<T> {\n    return this;\n  }\n\n  static of<T>(data: FiniteCollection<T>): ImmutableList<T>;\n  static of<T>(data: T[]): ImmutableList<T>;\n  static of<DataTransferItem>(data: DataTransferItemList): ImmutableList<DataTransferItem>;\n  static of<T>(data: ItemList<T>): ImmutableList<T>;\n  static of(\n      data: any[] |\n          FiniteCollection<any> |\n          ItemList<any> |\n          DataTransferItemList): ImmutableList<any> {\n    if (FiniteIterableType.check(data)) {\n      return new ImmutableList<any>([...data]);\n    } else if (ItemListType<any>().check(data)) {\n      const array: any[] = [];\n      for (let i = 0; i < data.length; i++) {\n        array.push(data.item(i));\n      }\n      return new ImmutableList(array);\n    } else if (data instanceof DataTransferItemList) {\n      const array: DataTransferItem[] = [];\n      for (let i = 0; i < data.length; i++) {\n        array.push(data[i]);\n      }\n      return new ImmutableList<DataTransferItem>(array);\n    } else if (data instanceof Array) {\n      return new ImmutableList<any>(data);\n    } else {\n      throw assertUnreachable(data);\n    }\n  }\n}\n","import { FiniteIterableType, InstanceofType, Type } from '../check';\nimport { FiniteCollection, FiniteIndexed, Ordering } from '../interfaces';\nimport { ImmutableSet } from './immutable-set';\nimport { OrderedMap } from './ordered-map';\nimport { Orderings } from './orderings';\n\nexport class ImmutableMap<K, V> implements\n    FiniteCollection<[K, V]>,\n    FiniteIndexed<K, V> {\n  private readonly data_: Map<K, V>;\n\n  constructor(data: Map<K, V>) {\n    this.data_ = new Map(data);\n  }\n\n  [Symbol.iterator](): Iterator<[K, V]> {\n    return this.data_[Symbol.iterator]();\n  }\n\n  add([key, value]: [K, V]): ImmutableMap<K, V> {\n    return this.set(key, value);\n  }\n\n  addAll(items: FiniteCollection<[K, V]>): ImmutableMap<K, V> {\n    const clone = new Map(this.data_);\n    for (const [key, value] of items) {\n      clone.set(key, value);\n    }\n    return new ImmutableMap(clone);\n  }\n\n  delete([key, _]: [K, V]): ImmutableMap<K, V> {\n    const clone = new Map(this.data_);\n    clone.delete(key);\n    return new ImmutableMap(clone);\n  }\n\n  deleteAll(items: FiniteCollection<[K, V]>): ImmutableMap<K, V> {\n    const clone = new Map(this.data_);\n    for (const [key, _] of items) {\n      clone.delete(key);\n    }\n    return new ImmutableMap(clone);\n  }\n\n  deleteAllKeys(keys: FiniteCollection<K>): ImmutableMap<K, V> {\n    const clone = new Map(this.data_);\n    for (const key of keys) {\n      clone.delete(key);\n    }\n    return new ImmutableMap(clone);\n  }\n\n  deleteKey(key: K): ImmutableMap<K, V> {\n    const clone = new Map(this.data_);\n    clone.delete(key);\n    return new ImmutableMap(clone);\n  }\n\n  entries(): ImmutableSet<[K, V]> {\n    return ImmutableSet.of<[K, V]>(this);\n  }\n\n  every(check: (value: V, key: K) => boolean): boolean {\n    return this.everyItem(([key, value]: [K, V]) => {\n      return check(value, key);\n    });\n  }\n\n  everyItem(check: (item: [K, V]) => boolean): boolean {\n    for (const entry of this) {\n      if (!check(entry)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  filter(checker: (value: V, index: K) => boolean): ImmutableMap<K, V> {\n    return this.filterItem(([key, value]: [K, V]) => checker(value, key));\n  }\n\n  filterByType<T2>(checker: Type<T2>): ImmutableSet<T2> {\n    const newItems: T2[] = [];\n    for (const item of this) {\n      if (checker.check(item)) {\n        newItems.push(item);\n      }\n    }\n    return ImmutableSet.of(newItems);\n  }\n\n  filterItem(checker: (item: [K, V]) => boolean): ImmutableMap<K, V> {\n    return ImmutableMap.of(this.entries().filterItem(checker));\n  }\n\n  find(check: (item: [K, V]) => boolean): [K, V] | null {\n    return this.findEntry((value: V, index: K) => {\n      return check([index, value]);\n    });\n  }\n\n  findEntry(checker: (value: V, index: K) => boolean): [K, V] | null {\n    for (const [index, value] of this.entries()) {\n      if (checker(value, index)) {\n        return [index, value];\n      }\n    }\n    return null;\n  }\n\n  findKey(checker: (value: V, index: K) => boolean): K | null {\n    const entry = this.findEntry(checker);\n    return entry === null ? null : entry[0];\n  }\n\n  findValue(checker: (value: V, index: K) => boolean): V | null {\n    const entry = this.findEntry(checker);\n    return entry === null ? null : entry[1];\n  }\n\n  get(index: K): V | undefined {\n    return this.data_.get(index);\n  }\n\n  has([key, value]: [K, V]): boolean {\n    return this.data_.get(key) === value;\n  }\n\n  hasKey(key: K): boolean {\n    return this.data_.has(key);\n  }\n\n  keys(): ImmutableSet<K> {\n    return this.entries()\n        .mapItem(([key, _]: [K, V]) => {\n          return key;\n        });\n  }\n\n  map<R>(fn: (value: V, index: K) => R): ImmutableMap<K, R> {\n    const mappedEntries = this.entries()\n        .mapItem(([key, value]: [K, V]) => {\n          return [key, fn(value, key)] as [K, R];\n        });\n    return ImmutableMap.of(mappedEntries);\n  }\n\n  mapItem<R>(fn: (item: [K, V]) => R): ImmutableSet<R> {\n    const mappedEntries = this.entries()\n        .mapItem(([key, value]: [K, V]) => {\n          return fn([key, value]);\n        });\n    return ImmutableSet.of(mappedEntries);\n  }\n\n  max(ordering: Ordering<[K, V]>): [K, V] | null {\n    return this.reduceItem<[K, V] | null>(\n        (prevValue: [K, V] | null, currentEntry: [K, V]) => {\n          if (prevValue === null) {\n            return currentEntry;\n          }\n\n          if (ordering(prevValue, currentEntry) === -1) {\n            return currentEntry;\n          } else {\n            return prevValue;\n          }\n        },\n        null);\n  }\n\n  min(ordering: Ordering<[K, V]>): [K, V] | null {\n    return this.max(Orderings.reverse(ordering));\n  }\n\n  reduce<R>(fn: (prevValue: R, value: V, key: K) => R, init: R): R {\n    let result: R = init;\n    for (const [key, value] of this.data_) {\n      result = fn(result, value, key);\n    }\n    return result;\n  }\n\n  reduceItem<R>(fn: (prevItem: R, item: [K, V]) => R, init: R): R {\n    return this.reduce((prevValue: R, value: V, key: K) => {\n      return fn(prevValue, [key, value]);\n    }, init);\n  }\n\n  set(key: K, item: V): ImmutableMap<K, V> {\n    const clone = new Map(this.data_);\n    clone.set(key, item);\n    return new ImmutableMap(clone);\n  }\n\n  setForTest(key: K, value: V): void {\n    this.data_.set(key, value);\n  }\n\n  size(): number {\n    return this.data_.size;\n  }\n\n  some(check: (value: V, key: K) => boolean): boolean {\n    return this.someItem(([key, value]: [K, V]) => {\n      return check(value, key);\n    });\n  }\n\n  someItem(check: (item: [K, V]) => boolean): boolean {\n    for (const entry of this) {\n      if (check(entry)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  sort(ordering: Ordering<[K, V]>): OrderedMap<K, V> {\n    return OrderedMap.of([...this.entries().sort(ordering)]);\n  }\n\n  values(): ImmutableSet<V> {\n    return this.entries()\n        .mapItem(([_, value]: [K, V]) => {\n          return value;\n        });\n  }\n\n  static of<K, V>(data: FiniteCollection<[K, V]>): ImmutableMap<K, V>;\n  static of<K, V>(data: [K, V][]): ImmutableMap<K, V>;\n  static of<K, V>(data: Map<K, V>): ImmutableMap<K, V>;\n  static of<V>(data: {[key: string]: V}): ImmutableMap<string, V>;\n  static of(data: gs.IJson): ImmutableMap<string, any>;\n  static of<K, V>(data: FiniteCollection<[K, V]> | [K, V][] | gs.IJson | Map<K, V>):\n      ImmutableMap<any, any> {\n    if (FiniteIterableType.check(data)) {\n      return new ImmutableMap(new Map(data));\n    } else if (InstanceofType(Array).check(data)) {\n      return new ImmutableMap(new Map(data));\n    } else if (data instanceof Map) {\n      return new ImmutableMap(new Map(data));\n    } else {\n      const entries: [string, any][] = [];\n      for (const key in data) {\n        entries.push([key, data[key]]);\n      }\n      return new ImmutableMap(new Map(entries));\n    }\n  }\n}\n","import { Type } from '../check';\nimport { FiniteIterableType } from '../check/finite-iterable-type';\nimport { InstanceofType } from '../check/instanceof-type';\nimport { Iterables } from '../immutable/iterables';\nimport { OrderedSet } from '../immutable/ordered-set';\nimport { Orderings } from '../immutable/orderings';\nimport { FiniteCollection } from '../interfaces/finite-collection';\nimport { Ordering } from '../interfaces/ordering';\nimport { assertUnreachable } from '../typescript/assert-unreachable';\n\nexport class ImmutableSet<T> implements FiniteCollection<T> {\n  private readonly data_: Set<T>;\n\n  constructor(data: Set<T>) {\n    this.data_ = new Set(Iterables.clone(data));\n  }\n\n  [Symbol.iterator](): Iterator<T> {\n    return this.data_[Symbol.iterator]();\n  }\n\n  add(item: T): ImmutableSet<T> {\n    const clone = new Set(Iterables.clone(this.data_));\n    clone.add(item);\n    return new ImmutableSet(clone);\n  }\n\n  addAll(items: FiniteCollection<T>): ImmutableSet<T> {\n    const clone = new Set(Iterables.clone(this.data_));\n    for (const item of items) {\n      clone.add(item);\n    }\n    return new ImmutableSet(clone);\n  }\n\n  delete(item: T): ImmutableSet<T> {\n    const clone = new Set(Iterables.clone(this.data_));\n    clone.delete(item);\n    return new ImmutableSet(clone);\n  }\n\n  deleteAll(items: FiniteCollection<T>): ImmutableSet<T> {\n    const clone = new Set(Iterables.clone(this.data_));\n    for (const item of items) {\n      clone.delete(item);\n    }\n    return new ImmutableSet(clone);\n  }\n\n  everyItem(check: (item: T) => boolean): boolean {\n    for (const item of this) {\n      if (!check(item)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  filterByType<T2>(checker: Type<T2>): ImmutableSet<T2> {\n    const newItems: T2[] = [];\n    for (const item of this) {\n      if (checker.check(item)) {\n        newItems.push(item);\n      }\n    }\n    return ImmutableSet.of(newItems);\n  }\n\n  filterItem(checker: (item: T) => boolean): ImmutableSet<T> {\n    const iterable = this;\n    return new ImmutableSet(new Set(Iterables.of(function* (): IterableIterator<T> {\n      for (const item of iterable) {\n        if (checker(item)) {\n          yield item;\n        }\n      }\n    })));\n  }\n\n  find(check: (item: T) => boolean): T | null {\n    for (const item of this.data_) {\n      if (check(item)) {\n        return item;\n      }\n    }\n    return null;\n  }\n\n  has(item: T): boolean {\n    return this.data_.has(item);\n  }\n\n  mapItem<R>(fn: (item: T) => R): ImmutableSet<R> {\n    const iterable = this;\n    return new ImmutableSet(new Set(Iterables.of(function* (): IterableIterator<R> {\n      for (const item of iterable) {\n        yield fn(item);\n      }\n    })));\n  }\n\n  max(ordering: Ordering<T>): T | null {\n    return this.reduceItem(\n        (prevValue: T | null, value: T) => {\n          if (prevValue === null) {\n            return value;\n          }\n\n          if (ordering(prevValue, value) === -1) {\n            return value;\n          } else {\n            return prevValue;\n          }\n        },\n        null);\n  }\n\n  min(ordering: Ordering<T>): T | null {\n    return this.max(Orderings.reverse(ordering));\n  }\n\n  reduceItem<R>(fn: (prevItem: R, item: T) => R, init: R): R {\n    let result = init;\n    for (const item of this.data_) {\n      result = fn(result, item);\n    }\n    return result;\n  }\n\n  size(): number {\n    return this.data_.size;\n  }\n\n  someItem(check: (item: T) => boolean): boolean {\n    for (const item of this) {\n      if (check(item)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  sort(compareFn: Ordering<T>): OrderedSet<T> {\n    const arrayData = Array.from(this.data_);\n    return OrderedSet.of(arrayData.sort(compareFn));\n  }\n\n  static of<T>(data: FiniteCollection<T>): ImmutableSet<T>;\n  static of<T>(data: Set<T>): ImmutableSet<T>;\n  static of<T>(data: T[]): ImmutableSet<T>;\n  static of<T>(data: Set<T> | T[] | FiniteCollection<T>): ImmutableSet<T> {\n    if (InstanceofType<Set<T>>(Set).check(data)) {\n      return new ImmutableSet(data);\n    } else if (InstanceofType<T[]>(Array).check(data)) {\n      return new ImmutableSet(new Set(data));\n    } else if (FiniteIterableType.check(data)) {\n      return new ImmutableSet(new Set(data));\n    } else {\n      throw assertUnreachable(data);\n    }\n  }\n}\n","export { Generators } from './generators';\nexport { ImmutableList } from './immutable-list';\nexport { ImmutableMap } from './immutable-map';\nexport { ImmutableSet } from './immutable-set';\nexport { Iterables } from './iterables';\nexport { OrderedMap } from './ordered-map';\nexport { Orderings } from './orderings';\nexport { TreeMap } from './tree-map';\nexport { TreeSet } from './tree-set';\nexport { Vector2d } from './vector2d';\n","import { HasPropertyType, InstanceofType, IterableType, StringType, Type } from '../check';\nimport { assertUnreachable } from '../typescript';\n\nexport class Iterables {\n  static ITERATOR_TYPE: Type<Iterator<any>> =\n      HasPropertyType<Iterator<any>>('next', InstanceofType(Function));\n\n  static clone<T>(iterable: Iterable<T>): Iterable<T> {\n    return {\n      * [Symbol.iterator](): Iterator<T> {\n        for (const value of iterable) {\n          yield value;\n        }\n      },\n    };\n  }\n\n  static flatten<T>(iterables: Iterable<Iterable<T>>): Iterable<T> {\n    const output: T[] = [];\n    for (const iterable of iterables) {\n      for (const item of iterable) {\n        output.push(item);\n      }\n    }\n\n    return output;\n  }\n\n  static of<T>(generator: () => Iterator<T>): Iterable<T>;\n  static of<T>(iterator: Iterator<T>): Iterable<T>;\n  static of<T>(data: Iterator<T> | (() => Iterator<T>)): Iterable<T> {\n    if (Iterables.ITERATOR_TYPE.check(data)) {\n      return {\n        [Symbol.iterator](): Iterator<T> {\n          return data;\n        },\n      };\n    } else if (data instanceof Function) {\n      return Iterables.of<T>(data());\n    } else {\n      throw assertUnreachable(data);\n    }\n  }\n\n  static unsafeEquals<T>(iterable1: Iterable<T>, iterable2: Iterable<T>): boolean {\n    const array1 = [...iterable1];\n    const array2 = [...iterable2];\n    if (array1.length !== array2.length) {\n      return false;\n    }\n\n    for (let i = 0; i < array1.length; i++) {\n      const item1 = array1[i];\n      const item2 = array2[i];\n      if (IterableType.check(item1) &&\n          !StringType.check(item1) &&\n          IterableType.check(item2) &&\n          !StringType.check(item2) &&\n          Iterables.unsafeEquals(item1, item2)) {\n        continue;\n      }\n\n      if (item1 !== item2) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n","import { Type } from '../check';\nimport { ImmutableList } from '../immutable/immutable-list';\nimport { ImmutableSet } from '../immutable/immutable-set';\nimport { OrderedSet } from '../immutable/ordered-set';\nimport { Orderings } from '../immutable/orderings';\nimport {\n  Collection,\n  CompareResult,\n  FiniteCollection,\n  FiniteIndexed,\n  Ordered,\n  Ordering } from '../interfaces';\n\nexport class OrderedMap<K, V> implements\n    FiniteCollection<[K, V]>,\n    FiniteIndexed<K, V>,\n    Ordered<[K, V]> {\n  private readonly keys_: K[];\n  private readonly map_: Map<K, V>;\n\n  private constructor(keys: K[], map: Map<K, V>) {\n    this.keys_ = keys.slice(0);\n    this.map_ = new Map(map);\n  }\n\n  [Symbol.iterator](): Iterator<[K, V]> {\n    return this.entries()[Symbol.iterator]();\n  }\n\n  add([key, value]: [K, V]): OrderedMap<K, V> {\n    if (this.map_.has(key)) {\n      return this;\n    }\n\n    const keysClone = this.keys_.slice(0);\n    keysClone.push(key);\n    const mapClone = new Map(this.map_);\n    mapClone.set(key, value);\n    return new OrderedMap(keysClone, mapClone);\n  }\n\n  addAll(items: FiniteCollection<[K, V]>): OrderedMap<K, V> {\n    const keysClone = this.keys_.slice(0);\n    const mapClone = new Map(this.map_);\n    const entriesToAdd = items.filterItem(([key, _]: [K, V]) => !this.hasKey(key));\n    for (const [key, value] of entriesToAdd) {\n      keysClone.push(key);\n      mapClone.set(key, value);\n    }\n    return new OrderedMap(keysClone, mapClone);\n  }\n\n  delete(entry: [K, V]): OrderedMap<K, V> {\n    return this.deleteAll(ImmutableSet.of([entry]));\n  }\n\n  deleteAll(items: FiniteCollection<[K, V]>): OrderedMap<K, V> {\n    const keysClone = this.keys_.slice(0);\n    const mapClone = new Map(this.map_);\n\n    for (const [key, value] of items) {\n      if (this.map_.get(key) !== value) {\n        continue;\n      }\n\n      const index = keysClone.indexOf(key);\n      if (index >= 0) {\n        keysClone.splice(index, 1);\n      }\n      mapClone.delete(key);\n    }\n    return new OrderedMap(keysClone, mapClone);\n  }\n\n  deleteAllKeys(keys: FiniteCollection<K>): OrderedMap<K, V> {\n    const keysClone = this.keys_.slice(0);\n    const mapClone = new Map(this.map_);\n\n    for (const key of keys) {\n      const index = keysClone.indexOf(key);\n      if (index >= 0) {\n        keysClone.splice(index, 1);\n      }\n      mapClone.delete(key);\n    }\n    return new OrderedMap(keysClone, mapClone);\n  }\n\n  deleteAt(index: number): OrderedMap<K, V> {\n    const keyToDelete = this.keys_[index];\n    if (keyToDelete === undefined) {\n      return this;\n    }\n\n    return this.deleteKey(keyToDelete);\n  }\n\n  deleteKey(key: K): OrderedMap<K, V> {\n    return this.deleteAllKeys(ImmutableSet.of([key]));\n  }\n\n  entries(): ImmutableList<[K, V]> {\n    return ImmutableList\n        .of(this.keys_)\n        .map((key: K) => {\n          const value = this.map_.get(key);\n          if (value === undefined) {\n            throw new Error(`Data inconsistency detected: ${key} has undefined value`);\n          }\n          return [key, value] as [K, V];\n        });\n  }\n\n  equals(other: Ordered<[K, V]>): boolean {\n    if (this.size() !== other.size()) {\n      return false;\n    }\n\n    for (let i = 0; i < this.size(); i++) {\n      const [thisKey, thisValue] = this.getAt(i)!;\n      const [otherKey, otherValue] = other.getAt(i)!;\n      if (thisKey !== otherKey || thisValue !== otherValue) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  every(check: (value: V, key: K) => boolean): boolean {\n    return this.everyItem(([key, value]: [K, V]) => {\n      return check(value, key);\n    });\n  }\n\n  everyItem(check: (item: [K, V]) => boolean): boolean {\n    for (const entry of this) {\n      if (!check(entry)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  filter(checker: (value: V, index: K) => boolean): OrderedMap<K, V> {\n    return this.filterItem(([key, value]: [K, V]) => checker(value, key));\n  }\n\n  filterByType<T2>(checker: Type<T2>): OrderedSet<T2> {\n    const newItems: T2[] = [];\n    for (const item of this) {\n      if (checker.check(item)) {\n        newItems.push(item);\n      }\n    }\n    return OrderedSet.of(newItems);\n  }\n\n  filterItem(checker: (item: [K, V]) => boolean): OrderedMap<K, V> {\n    const filteredEntries = this.entries().filterItem(checker);\n    const keysClone = filteredEntries.mapItem(([key, _]: [K, V]) => key);\n    const mapClone = new Map([...filteredEntries]);\n    return new OrderedMap([...keysClone], mapClone);\n  }\n\n  find(check: (item: [K, V]) => boolean): [K, V] | null {\n    return this.findEntry((value: V, index: K) => {\n      return check([index, value]);\n    });\n  }\n\n  findEntry(checker: (value: V, index: K) => boolean): [K, V] | null {\n    for (const [index, value] of this.entries()) {\n      if (checker(value, index)) {\n        return [index, value];\n      }\n    }\n    return null;\n  }\n\n  findKey(checker: (value: V, index: K) => boolean): K | null {\n    const entry = this.findEntry(checker);\n    return entry === null ? null : entry[0];\n  }\n\n  findValue(checker: (value: V, index: K) => boolean): V | null {\n    const entry = this.findEntry(checker);\n    return entry === null ? null : entry[1];\n  }\n\n  get(key: K): V | undefined {\n    return this.map_.get(key);\n  }\n\n  getAt(index: number): [K, V] | undefined {\n    const key = this.keys_[index];\n    if (key === undefined) {\n      return undefined;\n    }\n\n    const value = this.get(key);\n    if (value === undefined) {\n      return undefined;\n    }\n\n    return [key, value];\n  }\n\n  has([key, value]: [K, V]): boolean {\n    return this.map_.get(key) === value;\n  }\n\n  hasKey(key: K): boolean {\n    return this.map_.has(key);\n  }\n\n  insertAllAt(index: number, items: FiniteCollection<[K, V]> & Collection<[K, V]>):\n      OrderedMap<K, V> {\n    const keysToInsert = ImmutableSet.of(items).mapItem(([key]: [K, V]) => key);\n    const keysClone = ImmutableList.of(this.keys_).insertAllAt(index, keysToInsert);\n    const mapClone = new Map(this.map_);\n    for (const [key, value] of items) {\n      mapClone.set(key, value);\n    }\n    return new OrderedMap([...keysClone], mapClone);\n  }\n\n  insertAt(index: number, item: [K, V]): OrderedMap<K, V> {\n    return this.insertAllAt(index, ImmutableSet.of([item]));\n  }\n\n  keys(): ImmutableList<K> {\n    return this.entries()\n        .mapItem(([key, _]: [K, V]) => {\n          return key;\n        });\n  }\n\n  map<R>(fn: (value: V, index: K) => R): OrderedMap<K, R> {\n    const keysClone = this.keys_.slice(0);\n    const mapClone = new Map();\n    for (const [key, value] of this.map_) {\n      mapClone.set(key, fn(value, key));\n    }\n    return new OrderedMap(keysClone, mapClone);\n  }\n\n  mapItem<R>(fn: (item: [K, V]) => R): OrderedSet<R> {\n    return OrderedSet.of([...this.map_].map((entry: [K, V]) => fn(entry)));\n  }\n\n  max(ordering: Ordering<[K, V]>): [K, V] | null {\n    return this.reduceItem<[K, V] | null>(\n        (prevValue: [K, V] | null, currentEntry: [K, V]) => {\n          if (prevValue === null) {\n            return currentEntry;\n          }\n\n          if (ordering(prevValue, currentEntry) === -1) {\n            return currentEntry;\n          } else {\n            return prevValue;\n          }\n        },\n        null);\n  }\n\n  min(ordering: Ordering<[K, V]>): [K, V] | null {\n    return this.max(Orderings.reverse(ordering));\n  }\n\n  reduce<R>(fn: (prevValue: R, value: V, key: K) => R, init: R): R {\n    let result = init;\n    for (const [key, value] of this) {\n      result = fn(result, value, key);\n    }\n    return result;\n  }\n\n  reduceItem<R>(fn: (prevItem: R, item: [K, V]) => R, init: R): R {\n    return this.reduce((prev: R, value: V, key: K) => {\n      return fn(prev, [key, value]);\n    }, init);\n  }\n\n  reverse(): OrderedMap<K, V> {\n    return new OrderedMap(this.keys_.reverse(), new Map(this.map_));\n  }\n\n  set(key: K, value: V): OrderedMap<K, V> {\n    const keysClone = this.keys_.slice(0);\n    const mapClone = new Map(this.map_);\n    mapClone.set(key, value);\n    return new OrderedMap(keysClone, mapClone);\n  }\n\n  setAt(index: number, value: [K, V]): OrderedMap<K, V> {\n    return this.deleteAt(index).insertAt(index, value);\n  }\n\n  size(): number {\n    return this.keys_.length;\n  }\n\n  some(check: (value: V, key: K) => boolean): boolean {\n    return this.someItem(([key, value]: [K, V]) => {\n      return check(value, key);\n    });\n  }\n\n  someItem(check: (item: [K, V]) => boolean): boolean {\n    for (const entry of this) {\n      if (check(entry)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  sort(compareFn: (item1: [K, V], item2: [K, V]) => CompareResult): OrderedMap<K, V> {\n    const keysClone = this.keys_.slice(0).sort((key1: K, key2: K) => {\n      const value1 = this.get(key1);\n      const value2 = this.get(key2);\n      if (value1 === undefined) {\n        throw new Error(`Data inconsistency detected: ${key1} has undefined value`);\n      }\n      if (value2 === undefined) {\n        throw new Error(`Data inconsistency detected: ${key2} has undefined value`);\n      }\n      return compareFn([key1, value1], [key2, value2]);\n    });\n    return new OrderedMap(keysClone, new Map(this.map_));\n  }\n\n  values(): ImmutableList<V> {\n    return this.entries()\n        .mapItem(([_, value]: [K, V]) => {\n          return value;\n        });\n  }\n\n  static of<K, V>(entries: [K, V][]): OrderedMap<K, V> {\n    const keys: K[] = [];\n    const map = new Map();\n    for (const [key, value] of entries) {\n      if (!map.has(key)) {\n        keys.push(key);\n        map.set(key, value);\n      }\n    }\n\n    return new OrderedMap(keys, map);\n  }\n}\n","import { Type } from '../check';\nimport { CompareResult, FiniteCollection, Ordered, Ordering } from '../interfaces';\nimport { ImmutableSet } from './immutable-set';\nimport { Orderings } from './orderings';\n\nexport class OrderedSet<T> implements FiniteCollection<T>, Ordered<T> {\n  private readonly data_: T[];\n  private readonly set_: Set<T>;\n\n  private constructor(data: T[]) {\n    this.data_ = data;\n    this.set_ = new Set(data);\n  }\n\n  [Symbol.iterator](): Iterator<T> {\n    return this.data_[Symbol.iterator]();\n  }\n\n  add(item: T): OrderedSet<T> {\n    if (this.set_.has(item)) {\n      return this;\n    }\n\n    const clone = this.data_.slice(0);\n    clone.push(item);\n    return new OrderedSet(clone);\n  }\n\n  addAll(items: FiniteCollection<T>): OrderedSet<T> {\n    const clone = this.data_.slice(0);\n    const itemsToAdd = items.filterItem((item: T) => !this.has(item));\n    for (const item of itemsToAdd) {\n      clone.push(item);\n    }\n    return new OrderedSet(clone);\n  }\n\n  delete(item: T): OrderedSet<T> {\n    const index = this.data_.indexOf(item);\n    if (index < 0) {\n      return this;\n    }\n\n    const clone = this.data_.slice(0);\n    clone.splice(index, 1);\n    return new OrderedSet(clone);\n  }\n\n  deleteAll(items: FiniteCollection<T>): OrderedSet<T> {\n    const clone = this.data_.slice(0);\n    for (const item of items) {\n      const index = clone.indexOf(item);\n      if (index >= 0) {\n        clone.splice(index, 1);\n      }\n    }\n    return new OrderedSet(clone);\n  }\n\n  deleteAt(index: number): OrderedSet<T> {\n    const clone = this.data_.slice(0);\n    clone.splice(index, 1);\n    return new OrderedSet(clone);\n  }\n\n  equals(other: Ordered<T>): boolean {\n    if (this.size() !== other.size()) {\n      return false;\n    }\n\n    for (let i = 0; i < this.size(); i++) {\n      if (this.getAt(i) !== other.getAt(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  everyItem(check: (item: T) => boolean): boolean {\n    for (const item of this) {\n      if (!check(item)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  filterByType<T2>(checker: Type<T2>): OrderedSet<T2> {\n    const newItems: T2[] = [];\n    for (const item of this) {\n      if (checker.check(item)) {\n        newItems.push(item);\n      }\n    }\n    return OrderedSet.of(newItems);\n  }\n\n  filterItem(checker: (item: T) => boolean): OrderedSet<T> {\n    return new OrderedSet(this.data_.slice(0).filter((item: T) => {\n      return checker(item);\n    }));\n  }\n\n  find(check: (item: T) => boolean): T | null {\n    for (const item of this.data_) {\n      if (check(item)) {\n        return item;\n      }\n    }\n    return null;\n  }\n\n  getAt(index: number): T | undefined {\n    return this.data_[index];\n  }\n\n  has(item: T): boolean {\n    return this.set_.has(item);\n  }\n\n  insertAllAt(index: number, items: FiniteCollection<T>): OrderedSet<T> {\n    // Go through the items to add, and count the number of existing items that come before the\n    // insertion index.\n    let preInsertionCount = 0;\n    for (const item of items) {\n      const existingIndex = this.data_.indexOf(item);\n      if (existingIndex >= 0 && existingIndex < index) {\n        preInsertionCount++;\n      }\n    }\n\n    const clone = [...this.deleteAll(items)];\n    clone.splice(index - preInsertionCount, 0, ...items);\n    return new OrderedSet<T>(clone);\n  }\n\n  insertAt(index: number, item: T): OrderedSet<T> {\n    return this.insertAllAt(index, ImmutableSet.of([item]));\n  }\n\n  mapItem<R>(fn: (item: T) => R): OrderedSet<R> {\n    return new OrderedSet(this.data_.slice(0).map((item: T) => {\n      return fn(item);\n    }));\n  }\n\n  max(ordering: Ordering<T>): T | null {\n    return this.reduceItem(\n        (prevValue: T | null, value: T) => {\n          if (prevValue === null) {\n            return value;\n          }\n\n          if (ordering(prevValue, value) === -1) {\n            return value;\n          } else {\n            return prevValue;\n          }\n        },\n        null);\n  }\n\n  min(ordering: Ordering<T>): T | null {\n    return this.max(Orderings.reverse(ordering));\n  }\n\n  reduceItem<R>(fn: (prevItem: R, item: T) => R, init: R): R {\n    return this.data_.reduce((prev: R, curr: T) => {\n      return fn(prev, curr);\n    }, init);\n  }\n\n  reverse(): OrderedSet<T> {\n    return new OrderedSet(this.data_.reverse());\n  }\n\n  setAt(index: number, item: T): OrderedSet<T> {\n    return this.deleteAt(index).insertAt(index, item);\n  }\n\n  size(): number {\n    return this.data_.length;\n  }\n\n  someItem(check: (item: T) => boolean): boolean {\n    for (const item of this) {\n      if (check(item)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  sort(compareFn: (item1: T, item2: T) => CompareResult): OrderedSet<T> {\n    const clone = this.data_.slice(0);\n    clone.sort(compareFn);\n    return new OrderedSet<T>(clone);\n  }\n\n  static of<T>(items: T[]): OrderedSet<T> {\n    const uniques: T[] = [];\n    const set = new Set();\n    for (const item of items) {\n      if (!set.has(item)) {\n        set.add(item);\n        uniques.push(item);\n      }\n    }\n    return new OrderedSet(uniques);\n  }\n}\n","import { NumberType, StringType, Type } from '../check';\nimport { ImmutableList } from '../immutable/immutable-list';\nimport { CompareResult } from '../interfaces/compare-result';\nimport { Ordering } from '../interfaces/ordering';\nimport { FloatParser } from '../parse/float-parser';\n\nconst NATURAL_SPLIT_REGEXP = /([0-9]+)/;\n\nexport const Orderings = {\n  compound<T>(orderings: Iterable<Ordering<T>>): Ordering<T> {\n    return (item1: T, item2: T): CompareResult => {\n      for (const ordering of orderings) {\n        const result = ordering(item1, item2);\n        if (result !== 0) {\n          return result;\n        }\n      }\n      return 0;\n    };\n  },\n\n  map<T1, T2>(mapFn: (input: T1) => T2, ordering: Ordering<T2>): Ordering<T1> {\n    return (item1: T1, item2: T1): CompareResult => {\n      return ordering(mapFn(item1), mapFn(item2));\n    };\n  },\n\n  matches<T>(matchFn: (input: T) => boolean): Ordering<T> {\n    return (item1: T, item2: T): CompareResult => {\n      const matches1 = matchFn(item1);\n      const matches2 = matchFn(item2);\n      if (matches1 === matches2) {\n        return 0;\n      }\n\n      return (matches1 && !matches2) ? -1 : 1;\n    };\n  },\n\n  /**\n   * Orders items matching the given list at the start of the list.\n   * @param checked\n   */\n  isOneOf<T>(checked: Iterable<T>): Ordering<T> {\n    const checkedSet = new Set(checked);\n    return Orderings.matches(item => checkedSet.has(item));\n  },\n\n  /**\n   * Natural ordering that pays attention to numerical values in the string.\n   */\n  natural(): Ordering<string> {\n    return (item1: string, item2: string): CompareResult => {\n      const item1Chunks = item1.split(NATURAL_SPLIT_REGEXP);\n      const item2Chunks = item2.split(NATURAL_SPLIT_REGEXP);\n      const maxLength = Math.min(item1Chunks.length, item2Chunks.length);\n      const ordering = Orderings\n          .compound<any>(ImmutableList.of([\n            Orderings.type(ImmutableList.of([NumberType, StringType])),\n            Orderings.normal(),\n          ]));\n\n      function normalize(str: string): number | string {\n        const parsed = FloatParser.parse(str);\n        return parsed === null ? str : parsed;\n      }\n\n      for (let i = 0; i < maxLength; i++) {\n        const result = ordering(normalize(item1Chunks[i]), normalize(item2Chunks[i]));\n        if (result !== 0) {\n          return result;\n        }\n      }\n      return 0;\n    };\n  },\n\n  /**\n   * Ordering by comparators `<` and `>`.\n   *\n   * For numbers, this is the natural ordering of the number.\n   * For strings, this is the alphabetical ordering.\n   * For booleans, this ordering treats `false` as smaller.\n   */\n  normal<T>(): Ordering<T> {\n    return (item1: T, item2: T): CompareResult => {\n      if (item1 < item2) {\n        return -1;\n      } else if (item1 > item2) {\n        return 1;\n      } else {\n        return 0;\n      }\n    };\n  },\n\n  /**\n   * Reverses the given ordering.\n   */\n  reverse<T>(ordering: Ordering<T>): Ordering<T> {\n    return (item1: T, item2: T): CompareResult => {\n      return ordering(item2, item1);\n    };\n  },\n\n  /**\n   * Order the items by the types.\n   */\n  type(types: Iterable<Type<any>>): Ordering<any> {\n    return (item1: any, item2: any): CompareResult => {\n      for (const type of types) {\n        const passes1 = type.check(item1);\n        const passes2 = type.check(item2);\n        if (passes1 !== passes2) {\n          return Orderings.reverse(Orderings.normal())(passes1, passes2);\n        }\n      }\n\n      return 0;\n    };\n  },\n};\n","import { InstanceofType, NonNullType, TupleOfType } from '../check';\nimport { cache } from '../data';\nimport { ImmutableList } from '../immutable/immutable-list';\nimport { ImmutableMap } from '../immutable/immutable-map';\nimport { ImmutableSet } from '../immutable/immutable-set';\nimport { Collection } from '../interfaces';\nimport { Tree } from '../interfaces/tree';\n\ntype MapFn<K, V, K2, V2> =\n    (node: TreeMap<K, V>, key: K | null, parent: TreeMap<K, V> | null) => [K2 | null, V2];\n\n/**\n * Tree whose child nodes are indexed by the keys.\n */\nexport class TreeMap<K, V> implements Tree<K, V, ImmutableSet<V>> {\n  constructor(\n      private readonly value_: V,\n      private readonly childNodes_: ImmutableMap<K, TreeMap<K, V>> = ImmutableMap.of([])) { }\n\n  delete(key: K): TreeMap<K, V> {\n    return new TreeMap(this.value_, this.childNodes_.deleteKey(key));\n  }\n\n  getChildNode(key: K): TreeMap<K, V> | null {\n    return this.childNodes_.get(key) || null;\n  }\n\n  getChildren(): ImmutableSet<V> {\n    return this.childNodes_.mapItem(([, node]) => node.getValue());\n  }\n\n  getKeys(): ImmutableSet<K> {\n    return this.childNodes_.keys();\n  }\n\n  getValue(): V {\n    return this.value_;\n  }\n\n  map<K2, V2>(fn: MapFn<K, V, K2, V2>): TreeMap<K2, V2> {\n    return this.mapHelper_(fn, null, null)[1];\n  }\n\n  private mapHelper_<K2, V2>(\n      fn: MapFn<K, V, K2, V2>,\n      key: K | null,\n      parent: TreeMap<K, V> | null): [K2 | null, TreeMap<K2, V2>] {\n    const [newKey, newValue] = fn(this, key, parent);\n    const newChildren = ImmutableMap\n        .of(this.childNodes_.mapItem(([key, value]) => {\n          return value.mapHelper_(fn, key, this);\n        }))\n        .filterByType((TupleOfType([NonNullType<K2>(), InstanceofType<TreeMap<K2, V2>>(TreeMap)])));\n    return [newKey, TreeMap.of(newValue, newChildren)];\n  }\n\n  @cache()\n  postOrder(): ImmutableList<TreeMap<K, V>> {\n    return this.childNodes_\n        .map((node) => node.postOrder())\n        .reduce((prevValue, value) => prevValue.addAll(value), ImmutableList.of<TreeMap<K, V>>([]))\n        .add(this);\n  }\n\n  @cache()\n  preOrder(): ImmutableList<TreeMap<K, V>> {\n    const descendants = this.childNodes_\n        .map((node) => node.preOrder())\n        .reduce((prevValue, value) => prevValue.addAll(value), ImmutableList.of<TreeMap<K, V>>([]));\n    return ImmutableList.of([this, ...descendants]);\n  }\n\n  set(key: K, value: TreeMap<K, V>): TreeMap<K, V> {\n    return new TreeMap(this.value_, this.childNodes_.set(key, value));\n  }\n\n  setValue(value: V): TreeMap<K, V> {\n    return new TreeMap(value, this.childNodes_);\n  }\n\n  static of<K, V>(\n      value: V,\n      children: Iterable<[K, TreeMap<K, V>]> = new Map<K, TreeMap<K, V>>()): TreeMap<K, V> {\n    return new TreeMap(value, ImmutableMap.of<K, TreeMap<K, V>>([...children]));\n  }\n\n  static async promiseAll<K, V>(tree: TreeMap<K, Promise<V>>): Promise<TreeMap<K, V>> {\n    const promises: Promise<[Tree<K, Promise<V>, Collection<Promise<V>>>, V]>[] = [];\n    for (const node of tree.postOrder()) {\n      promises.push(Promise.all([node, node.getValue()]));\n    }\n\n    const results = await Promise.all(promises);\n    const resultsMap = ImmutableMap.of(results);\n    return tree.map((node, key) => [key, resultsMap.get(node)!]);\n  }\n}\n","import { cache } from '../data';\nimport { ImmutableList } from '../immutable/immutable-list';\nimport { ImmutableMap } from '../immutable/immutable-map';\nimport { ImmutableSet } from '../immutable/immutable-set';\nimport { Tree } from '../interfaces/tree';\n\ntype MapFn<V, V2> = (node: TreeSet<V>, parent: TreeSet<V> | null) => V2;\n\n/**\n * Tree whose child nodes are indexed by the values.\n */\nexport class TreeSet<V> implements Tree<V, V, ImmutableSet<V>> {\n  constructor(\n      private readonly value_: V,\n      private readonly childNodes_: ImmutableMap<V, TreeSet<V>> = ImmutableMap.of([])) { }\n\n  add(node: TreeSet<V>): TreeSet<V> {\n    return new TreeSet(\n        this.value_,\n        this.childNodes_.set(node.getValue(), node));\n  }\n\n  delete(value: V): TreeSet<V> {\n    return new TreeSet(this.value_, this.childNodes_.deleteKey(value));\n  }\n\n  getChildNode(key: V): TreeSet<V> | null {\n    return this.childNodes_.get(key) || null;\n  }\n\n  getChildren(): ImmutableSet<V> {\n    return this.childNodes_.keys();\n  }\n\n  getValue(): V {\n    return this.value_;\n  }\n\n  map<V2>(fn: MapFn<V, V2>): TreeSet<V2> {\n    return this.mapHelper_(fn, null);\n  }\n\n  private mapHelper_<V2>(\n      fn: MapFn<V, V2>,\n      parent: TreeSet<V> | null): TreeSet<V2> {\n    const newValue = fn(this, parent);\n    const newChildren = this.childNodes_.mapItem(([, value]) => {\n      const newNode = value.mapHelper_(fn, this);\n      return newNode;\n    });\n    return TreeSet.of(newValue, newChildren);\n  }\n\n  @cache()\n  postOrder(): ImmutableList<TreeSet<V>> {\n    return this.childNodes_\n        .map((node) => node.postOrder())\n        .reduce((prevValue, value) => prevValue.addAll(value), ImmutableList.of<TreeSet<V>>([]))\n        .add(this);\n  }\n\n  @cache()\n  preOrder(): ImmutableList<TreeSet<V>> {\n    const descendants = this.childNodes_\n        .map((node) => node.preOrder())\n        .reduce((prevValue, value) => prevValue.addAll(value), ImmutableList.of<TreeSet<V>>([]));\n    return ImmutableList.of([this, ...descendants]);\n  }\n\n  setValue(value: V): TreeSet<V> {\n    return new TreeSet(value, this.childNodes_);\n  }\n\n  static of<T>(value: T, children: Iterable<TreeSet<T>> = new Set()): TreeSet<T> {\n    const mapContent = ImmutableSet.of([...children])\n        .mapItem((child) => [child.getValue(), child] as [T, TreeSet<T>]);\n    return new TreeSet(value, ImmutableMap.of(mapContent));\n  }\n}\n","export class Vector2d {\n  constructor(\n      readonly x: number,\n      readonly y: number) { }\n\n  add(other: Vector2d): Vector2d {\n    return new Vector2d(this.x + other.x, this.y + other.y);\n  }\n\n  getLength(): number {\n    return Math.sqrt(this.getLengthSquared());\n  }\n\n  getLengthSquared(): number {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  mult(n: number): Vector2d {\n    return new Vector2d(this.x * n, this.y * n);\n  }\n\n  static of(x: number, y: number): Vector2d {\n    return new Vector2d(x, y);\n  }\n}\n","import { InjectMetadata } from './inject-metadata';\n\n\n/**\n * @hidden\n */\nconst __METADATA = Symbol('metadata');\n\nexport class InjectUtil {\n\n  /**\n   * Gets all binding metadata for the given constructor.\n   *\n   * @param ctor The constructor whose metadata should be returned.\n   * @return Map of binding metadata for the given constructor. The key is the parameter index. The\n   *    value is the binding key for that parameter index.\n   */\n  static getMetadataMap(ctor: gs.ICtor<any>): Map<number, InjectMetadata> {\n    if (ctor[__METADATA] === undefined) {\n      ctor[__METADATA] = new Map<number, InjectMetadata>();\n    }\n    return ctor[__METADATA];\n  }\n}\n// TODO: Mutable\n","import { Reflect } from '../util/reflect';\n\nimport { InjectUtil } from './inject-util';\n\n\n/**\n * Key for binding a value.\n *\n * You should be using `string`. This is done only for compatibility with the class decorator.\n */\ntype BindKey = string | symbol;\n\n/**\n * Function that accepts an Injector as an argument and returns a value to be bound.\n */\ntype Provider<T> = (injector: Injector) => T;\n\n/**\n * @hidden\n */\nconst INJECTOR_BIND_KEY_ = '$gsInjector';\n\n\n/**\n * Light dependency injection library.\n *\n * Using this consists of 3 parts:\n *\n * 1.  First, you will need to bind the class that can be injected. Apply the `@Bind` annotation on\n *     the class.\n * 1.  Next, on constructor parameters you want to do injection on, apply the `@Inject` annotation\n *     on the parameter.\n * 1.  To instantiate a class, use the [[instantiate]] method. This will inject any parameters\n *     marked by the `@Inject` annotation with the bound value. Note that any classes injected this\n *     way must have all of its constructor parameters be `@Inject`d.\n *\n * For example:\n *\n * ```typescript\n * import Bind from './inject/a-bind';\n * import Inject from './inject/a-inject';\n * import Injector from './inject/injector';\n *\n * // Ignore the \\. This is a bug with the typedoc parser.\n * \\@Bind()\n * class Service {\n *   constructor() {}\n * }\n *\n * class App {\n *   private service_: Service;\n *\n *   constructor(@Inject() Service) {\n *     this.service_ = Service;\n *   }\n * }\n *\n * let injector = new Injector();\n * let app = injector.instantiate(App);\n * ```\n *\n * By default, both `@Bind` and `@Inject` uses the class name and parameter name to determine the\n * binding key. However, you can override this behavior by specifying the names.\n *\n * You can always inject the injector by using the `$gsInjector` binding key. This means either\n * using `@Inject()` on a parameter called `$gsInjector` or by using `@Inject('$gsInjector')`.\n *\n * Any classes with `@Bind` are treated as singleton per instance of [[Injector]].\n */\nexport class Injector {\n  private static BINDINGS_: Map<BindKey, Provider<any>> = new Map<BindKey, Provider<any>>();\n\n  private instances_: Map<BindKey, any>;\n\n  /**\n   * @hidden\n   */\n  constructor() {\n    this.instances_ = new Map<BindKey, any>();\n    this.instances_.set(INJECTOR_BIND_KEY_, this);\n  }\n\n  /**\n   * Instantiates and returns the value bound to the given binding key.\n   *\n   * This is different from [[instantiate]] in that this only handles bound values and the instance\n   * created will be cached.\n   *\n   * For example:\n   *\n   * ```typescript\n   * \\@Bind('example-class')\n   * class ExampleClass {}\n   *\n   * let injector = new Injector();\n   * injector.getBoundValue('example-class');  // This will be cached.\n   * injector.instantiate(ExampleClass); // This is a different instance from the previous one.\n   * ```\n   *\n   * @param bindKey The key whose value should be returned.\n   * @return The instance bound to the given key.\n   */\n  getBoundValue(bindKey: BindKey, isOptional: boolean = false): any {\n    if (this.instances_.has(bindKey)) {\n      return this.instances_.get(bindKey);\n    }\n\n    if (!isOptional && !Injector.BINDINGS_.has(bindKey)) {\n      throw new Error(`No value bound to key ${bindKey}`);\n    }\n    const provider = Injector.BINDINGS_.has(bindKey)\n        ? Injector.BINDINGS_.get(bindKey) : () => undefined;\n    const instance = provider!(this);\n    this.instances_.set(bindKey, instance);\n\n    return instance;\n  }\n\n  /**\n   * Gets the resolved parameters of the given constructor.\n   *\n   * @param ctor The constructor whose parameters should be resolved.\n   * @param extraArguments Arguments to apply to the constructor parameter. The key should be the\n   *    parameter index, and the value is the value to assign to that index.\n   * @return Array of resolved parameters of the given constructor.\n   */\n  getParameters(ctor: gs.ICtor<any>, extraArguments: {[index: number]: any} = {}): any[] {\n    const metadataMap = InjectUtil.getMetadataMap(ctor);\n\n    // Collects the arguments.\n    const args: any[] = [];\n    for (let i = 0; i < ctor.length; i++) {\n      if (extraArguments[i] !== undefined) {\n        args.push(extraArguments[i]);\n      } else {\n        if (!metadataMap.has(i)) {\n          throw new Error(\n              `Cannot find injection candidate for index ${i} for ${ctor} when instantiating`);\n        }\n        const metadata = metadataMap.get(i);\n        args.push(this.getBoundValue(metadata!.getKeyName(), metadata!.isOptional()));\n      }\n    }\n    return args;\n  }\n\n\n  /**\n   * Instantiates the given constructor.\n   *\n   * This will check for any `@Inject` annotations on the parameter and use the `@Bind` values. If\n   * there are any parameters without `@Inject`, you have to specify the values in the\n   * extraArguments object.\n   *\n   * The extraArguments object can also be used to override parameters that are `@Inject` annotated.\n   *\n   * @param ctor The constructor to use to instantiates the object.\n   * @param extraArguments An object used to set the value of the constructor parameters. The index\n   *     is the parameter index and the value is the value to set for the corresponding parameter.\n   * @return The newly instantiated object.\n   */\n  instantiate<T>(ctor: gs.ICtor<T>, extraArguments: {[index: number]: any} = {}): T {\n    return Reflect.construct(ctor, this.getParameters(ctor, extraArguments));\n  }\n\n  /**\n   * Binds the given constructor to the given bind key.\n   *\n   * @param ctor The constructor to bind.\n   * @param bindKey The key to bind the constructor to.\n   */\n  static bind(ctor: gs.ICtor<any>, bindKey: BindKey): void {\n    Injector.bindProvider(\n        function(injector: Injector): any {\n          return injector.instantiate(ctor);\n        },\n        bindKey);\n  }\n\n  /**\n   * Binds the given provider to the given binding key.\n   *\n   * @param provider The provider to bind.\n   * @param bindKey The key to bind the provider to.\n   */\n  static bindProvider(\n      provider: Provider<any>,\n      bindKey: BindKey): void {\n    if (Injector.BINDINGS_.has(bindKey)) {\n      throw new Error(`Binding ${bindKey} is already bound`);\n    }\n\n    if (bindKey === INJECTOR_BIND_KEY_) {\n      throw new Error(`${INJECTOR_BIND_KEY_} is a reserved key`);\n    }\n    Injector.BINDINGS_.set(bindKey, provider);\n  }\n\n  /**\n   * @return A new Injector instane.\n   */\n  static newInstance(): Injector {\n    return new Injector();\n  }\n}\n// TODO: Mutable\n","import { BaseAssert } from './base-assert';\n\n\n/**\n * Assertion for any values..\n */\nexport class AnyAssert<T> extends BaseAssert {\n  /**\n   * Checks that the value is exactly the same instance as the given object.\n   */\n  be(other: any): void {\n    this.getMatchers_().toBe(other);\n  }\n\n  /**\n   * Checks that the value is an instance of the given class.\n   */\n  beAnInstanceOf(clazz: Object): void {\n    this.getMatchers_().toEqual(jasmine.any(clazz));\n  }\n\n  /**\n   * Checks that the value is defined.\n   */\n  beDefined(): void {\n    this.getMatchers_().toBeDefined();\n  }\n\n  /**\n   * Checks that the value is falsy.\n   */\n  beFalsy(): void {\n    this.getMatchers_().toBeFalsy();\n  }\n\n  /**\n   * Checks that the value is null.\n   */\n  beNull(): void {\n    this.getMatchers_().toBeNull();\n  }\n\n  /**\n   * Checks that the value is truthy.\n   */\n  beTruthy(): void {\n    this.getMatchers_().toBeTruthy();\n  }\n\n  /**\n   * Checks that the value is equal to the given value.\n   */\n  equal(other: T): void {\n    this.getMatchers_().toEqual(other);\n  }\n\n  /**\n   * Checks that the value is equal to object containing the given object.\n   * @param obj\n   */\n  matchObject(obj: any): void {\n    this.getMatchers_().toEqual(jasmine.objectContaining(obj));\n  }\n}\n","import { IterableAssert } from '../jasmine/iterable-assert';\n\n\nexport class ArrayAssert<T> extends IterableAssert<T> {\n  /**\n   * @param arrayValue_ The value to assert.\n   * @param reversed_ True iff the assertion logic should be reversed.\n   * @param expect_ Reference to jasmine's expect function.'\n   */\n  constructor(\n      arrayValue: T[],\n      reversed: boolean,\n      expect: (actual: any) => jasmine.Matchers<T[]>) {\n    super(arrayValue, reversed, expect);\n  }\n\n  /**\n   * Checks if the array contains the given element.\n   */\n  contain(element: T): void {\n    this.getMatchers_().toContain(element);\n  }\n}\n","import { Color } from '../interfaces/color';\nimport { AssertFactory } from '../jasmine/assert-factory';\nimport { ColorAssert } from '../jasmine/color-assert';\n\n\nexport function assertColor(value: Color | null): AssertFactory<ColorAssert> {\n  return new AssertFactory((reversed: boolean): ColorAssert => {\n    return new ColorAssert(value, reversed, expect);\n  });\n}\n// TODO: Mutable\n","/**\n * Generates Assert objects.\n */\nexport class AssertFactory<T> {\n  /**\n   * @param provider_ Provides the assert object. This takes in one parameter, which is true iff\n   *    the assertion logic should be reversed.\n   */\n  constructor(private provider_: (reversed: boolean) => T) { }\n\n  /**\n   * @return Instance of the assert with no check reversals.\n   */\n  get to(): T {\n    return this.provider_(false);\n  }\n\n  /**\n   * @return Instance of the assert with check reversal.\n   */\n  get toNot(): T {\n    return this.provider_(true);\n  }\n}\n// TODO: Mutable\n","import { BooleanType } from '../check/boolean-type';\nimport { FiniteIterableType } from '../check/finite-iterable-type';\nimport { IterableType } from '../check/iterable-type';\nimport { NumberType } from '../check/number-type';\nimport { StringType } from '../check/string-type';\nimport { Finite } from '../interfaces/finite';\nimport { AnyAssert } from '../jasmine/any-assert';\nimport { ArrayAssert } from '../jasmine/array-assert';\nimport { AssertFactory } from '../jasmine/assert-factory';\nimport { BaseAssert } from '../jasmine/base-assert';\nimport { BooleanAssert } from '../jasmine/boolean-assert';\nimport { ElementAssert } from '../jasmine/element-assert';\nimport { FiniteIterableAssert } from '../jasmine/finite-iterable-assert';\nimport { FunctionAssert } from '../jasmine/function-assert';\nimport { IterableAssert } from '../jasmine/iterable-assert';\nimport { MapAssert } from '../jasmine/map-assert';\nimport { NumberAssert } from '../jasmine/number-assert';\nimport { PromiseAssert } from '../jasmine/promise-assert';\nimport { SetAssert } from '../jasmine/set-assert';\nimport { StringAssert } from '../jasmine/string-assert';\n\n\n/**\n * Wraps jasmine's expect to add type safetiness.\n */\nexport function assert(value: boolean | null): AssertFactory<BooleanAssert>;\nexport function assert(value: number | null): AssertFactory<NumberAssert>;\nexport function assert(value: string | null): AssertFactory<StringAssert>;\nexport function assert(value: Element): AssertFactory<ElementAssert>;\n\nexport function assert<T>(value: Promise<T>): AssertFactory<PromiseAssert<T>>;\nexport function assert<T extends Function>(value: T | null): AssertFactory<FunctionAssert<T>>;\nexport function assert<T>(value: T[] | null): AssertFactory<ArrayAssert<T>>;\nexport function assert<K, V>(value: Map<K, V>): AssertFactory<MapAssert<K, V>>;\nexport function assert<T>(value: Set<T>): AssertFactory<SetAssert<T>>;\nexport function assert<T>(\n    iterable: Finite & Iterable<T>): AssertFactory<FiniteIterableAssert<T>>;\nexport function assert<T>(iterable: Iterable<T>): AssertFactory<IterableAssert<T>>;\nexport function assert(value: any): AssertFactory<AnyAssert<any>>;\nexport function assert(value: any): AssertFactory<BaseAssert> {\n  if (BooleanType.check(value)) {\n    return new AssertFactory((reversed: boolean): BooleanAssert => {\n      return new BooleanAssert(value, reversed, expect);\n    });\n  } else if (StringType.check(value)) {\n    return new AssertFactory((reversed: boolean): StringAssert => {\n      return new StringAssert(value, reversed, expect);\n    });\n  } else if (NumberType.check(value)) {\n    return new AssertFactory((reversed: boolean): NumberAssert => {\n      return new NumberAssert(value, reversed, expect);\n    });\n  } else if (value instanceof Element) {\n    return new AssertFactory((reversed: boolean): ElementAssert => {\n      return new ElementAssert(value, reversed, expect);\n    });\n  } else if (value instanceof Function) {\n    return new AssertFactory((reversed: boolean): FunctionAssert<any> => {\n      return new FunctionAssert(value, reversed, expect);\n    });\n  } else if (value instanceof Array) {\n    return new AssertFactory((reversed: boolean): ArrayAssert<any> => {\n      return new ArrayAssert<any>(value, reversed, expect);\n    });\n  } else if (value instanceof Map) {\n    return new AssertFactory((reversed: boolean): MapAssert<any, any> => {\n      return new MapAssert<any, any>(value, reversed, expect);\n    });\n  } else if (value instanceof Set) {\n    return new AssertFactory((reversed: boolean): SetAssert<any> => {\n      return new SetAssert<any>(value, reversed, expect);\n    });\n  } else if (value instanceof Promise) {\n    return new AssertFactory((reversed: boolean): PromiseAssert<any> => {\n      return new PromiseAssert<any>(value, fail, reversed, expect);\n    });\n  } else if (FiniteIterableType.check(value)) {\n    return new AssertFactory((reversed: boolean): FiniteIterableAssert<any> => {\n      return new FiniteIterableAssert<any>(value, reversed, expect);\n    });\n  } else if (IterableType.check(value)) {\n    return new AssertFactory((reversed: boolean): IterableAssert<any> => {\n      return new IterableAssert<any>(value, reversed, expect);\n    });\n  } else {\n    return new AssertFactory((reversed: boolean): AnyAssert<any> => {\n      return new AnyAssert(value, reversed, expect);\n    });\n  }\n}\n// TODO: Mutable\n","export class BaseAssert {\n  /**\n   * @param value_ The value to assert.\n   * @param reversed_ True iff the assertion logic should be reversed.\n   * @param expect_ Reference to jasmine's expect function.'\n   */\n  constructor(\n      private readonly anyValue_: any,\n      private readonly reversed_: boolean,\n      private readonly expect_: (actual: any) => jasmine.Matchers<any>) {\n  }\n\n  /**\n   * @return The base matchers object for checking.\n   */\n  protected getMatchers_(value: any = this.anyValue_): jasmine.Matchers<any> {\n    return this.reversed_ ? this.expect_(value).not : this.expect_(value);\n  }\n}\n// TODO: Mutable\n","import { BaseAssert } from '../jasmine/base-assert';\n\n\n/**\n * Boolean related assertions.\n */\nexport class BooleanAssert extends BaseAssert {\n  /**\n   * @param booleanValue_ The value to assert.\n   * @param reversed_ True iff the assertion logic should be reversed.\n   * @param expect_ Reference to jasmine's expect function.'\n   */\n  constructor(\n      booleanValue: boolean,\n      reversed: boolean,\n      expect: (actual: any) => jasmine.Matchers<boolean>) {\n    super(booleanValue, reversed, expect);\n  }\n\n  be(value: boolean | null): void {\n    this.getMatchers_().toBe(value);\n  }\n\n  /**\n   * Asserts that the value is false.\n   */\n  beFalse(): void {\n    this.be(false);\n  }\n\n  /**\n   * Asserts that the value is true.\n   */\n  beTrue(): void {\n    this.be(true);\n  }\n}\n","import { Color } from '../interfaces/color';\nimport { AnyAssert } from '../jasmine/any-assert';\n\n\nexport class ColorAssert extends AnyAssert<Color | null> {\n  private readonly colorValue_: Color | null;\n\n  constructor(\n      color: Color | null,\n      reversed: boolean,\n      expect: (actual: any) => jasmine.Matchers<Color | null>) {\n    super(color, reversed, expect);\n    this.colorValue_ = color;\n  }\n\n  /**\n   * Checks that the color has the given HSL components.\n   * @param hue The expected hue component.\n   * @param saturation The expected saturation component.\n   * @param lightness The expected lightness component.\n   */\n  haveHsl(hue: number, saturation: number, lightness: number): void {\n    if (this.colorValue_ === null) {\n      this.getMatchers_().not.toBeNull();\n      return;\n    }\n\n    const hslArray = [\n      this.colorValue_.getHue(),\n      this.colorValue_.getSaturation(),\n      this.colorValue_.getLightness(),\n    ];\n\n    this.getMatchers_(hslArray).toEqual([hue, saturation, lightness]);\n  }\n\n  /**\n   * Checks that the color has the given RGB components.\n   * @param red The expected red component.\n   * @param green The expected green component.\n   * @param blue The expected blue component.\n   */\n  haveRgb(red: number, green: number, blue: number): void {\n    if (this.colorValue_ === null) {\n      this.getMatchers_().not.toBeNull();\n      return;\n    }\n\n    const rgbArray = [\n      this.colorValue_.getRed(),\n      this.colorValue_.getGreen(),\n      this.colorValue_.getBlue(),\n    ];\n\n    this.getMatchers_(rgbArray).toEqual([red, green, blue]);\n  }\n}\n// TODO: Mutable\n","import { AnyAssert } from './any-assert';\n\n\nexport class ElementAssert extends AnyAssert<Element> {\n  private readonly elementValue_: Element;\n\n  constructor(\n      elementValue: Element,\n      reversed: boolean,\n      expect: (actual: any) => jasmine.Matchers<Element>) {\n    super(elementValue, reversed, expect);\n    this.elementValue_ = elementValue;\n  }\n\n  /**\n   * Asserts that the element has the specified children.\n   */\n  haveChildren(expectedChildren: Element[]): void {\n    const children: Element[] = [];\n    for (let i = 0; i < this.elementValue_.children.length; i++) {\n      children.push(this.elementValue_.children.item(i));\n    }\n\n    this.getMatchers_(children).toEqual(expectedChildren);\n  }\n\n  haveClasses(expectedClasses: string[]): void {\n    const classes: string[] = [];\n    for (let i = 0; i < this.elementValue_.classList.length; i++) {\n      classes.push(this.elementValue_.classList.item(i));\n    }\n    this.getMatchers_(classes).toEqual(expectedClasses);\n  }\n}\n","import { Finite } from '../interfaces/finite';\nimport { IterableAssert } from '../jasmine/iterable-assert';\n\nexport class FiniteIterableAssert<T> extends IterableAssert<T> {\n  constructor(\n      private finiteIterableValue_: Finite & Iterable<T>,\n      reversed: boolean,\n      expect: (actual: any) => jasmine.Matchers<Iterable<T>>) {\n    super(finiteIterableValue_, reversed, expect);\n  }\n\n  haveElements(elements: T[]): void {\n    const values: T[] = [];\n    for (const value of this.finiteIterableValue_) {\n      values.push(value);\n    }\n    this.getMatchers_(values).toEqual(elements);\n  }\n}\n","import { AnyAssert } from './any-assert';\n\n\nexport class FunctionAssert<T extends Function> extends AnyAssert<T> {\n  /**\n   * @param functionValue_ The value to assert.\n   * @param reversed_ True iff the assertion logic should be reversed.\n   * @param expect_ Reference to jasmine's expect function.'\n   */\n  constructor(\n      functionValue: T,\n      reversed: boolean,\n      expect: (actual: any) => jasmine.Matchers<T>) {\n    super(functionValue, reversed, expect);\n  }\n\n  /**\n   * Checks that the given function has been called.\n   */\n  haveBeenCalled(): void {\n    this.getMatchers_().toHaveBeenCalled();\n  }\n\n  /**\n   * Checks that the given function has been called the given number of times.\n   * @param times Expected number of times that the function has been called.\n   */\n  haveBeenCalledTimes(times: number): void {\n    this.getMatchers_().toHaveBeenCalledTimes(times);\n  }\n\n  /**\n   * Checks that the given function has been called with the given arguments.\n   */\n  get haveBeenCalledWith(): T {\n    return ((...args: any[]) => {\n      const matchers = this.getMatchers_();\n      matchers.toHaveBeenCalledWith.apply(matchers, args);\n    }) as any as T;\n  }\n\n  /**\n   * Checks that invoking the given function will throw an error.\n   */\n  throw(): void {\n    this.getMatchers_().toThrow();\n  }\n\n  /**\n   * Checks that invoking the given function will throw error with message matching the given\n   * Regexp.\n   *\n   * @param regexp Regular expression that the error message should match.\n   */\n  throwError(regexp: RegExp): void {\n    this.getMatchers_().toThrowError(regexp);\n  }\n}\n// TODO: Mutable\n","import { AnyAssert } from './any-assert';\n\n\nexport class IterableAssert<T> extends AnyAssert<Iterable<T>> {\n  /**\n   * @param iterableValue_ The value to assert.\n   * @param reversed_ True iff the assertion logic should be reversed.\n   * @param expect_ Reference to jasmine's expect function.'\n   */\n  constructor(\n      private iterableValue_: Iterable<T>,\n      reversed: boolean,\n      expect: (actual: any) => jasmine.Matchers<Iterable<T>>) {\n    super(iterableValue_, reversed, expect);\n  }\n\n  startWith(expected: T[]): void {\n    const iterator = this.iterableValue_[Symbol.iterator]();\n\n    // Collect the first few elements of the iterator.\n    const toCheck: T[] = [];\n    let result = iterator.next();\n    for (const _ of expected) {\n      if (result.done) {\n        break;\n      }\n\n      toCheck.push(result.value);\n      result = iterator.next();\n    }\n    this.getMatchers_(toCheck).toEqual(expected);\n  }\n}\n// TODO: Mutable\n","import { ImmutableMap } from '../immutable';\nimport { AnyAssert } from '../jasmine/any-assert';\n\n\n/**\n * Map related assertions.\n */\nexport class MapAssert<K, V> extends AnyAssert<Map<K, V>> {\n  private mapValue_: Map<K, V>;\n\n  /**\n   * @param mapValue The value to assert.\n   * @param reversed True iff the assertion logic should be reversed.\n   * @param expect Reference to jasmine's expect function.'\n   */\n  constructor(\n      mapValue: Map<K, V>,\n      reversed: boolean,\n      expect: (actual: any) => jasmine.Matchers<Map<K, V>>) {\n    super(mapValue, reversed, expect);\n    this.mapValue_ = mapValue;\n  }\n\n  /**\n   * @param entries Entries that the map should have.\n   */\n  haveEntries(entries: [K, V][]): void {\n    this.getMatchers_([...ImmutableMap.of(this.mapValue_).entries()]).toEqual(entries);\n  }\n}\n","type AsymmetricMatcher = {asymmetricMatch: (value: any, ...args: any[]) => boolean};\ntype MapFn<T1, T2> = (value: T1) => T2;\n\nclass MatcherBuilder {\n  constructor(private mapFns_: MapFn<any, any>[]) { }\n\n  any<T>(ctor: new (...args: any[]) => T): T {\n    return this.createMatcher_(jasmine.any(ctor) as any as AsymmetricMatcher) as any as T;\n  }\n\n  anyFunction<R>(): () => R;\n  anyFunction<P1, R>(): (arg1: P1) => R;\n  anyFunction(): any {\n    return this.createMatcher_(jasmine.any(Function) as any as AsymmetricMatcher);\n  }\n\n  anyInstanceOf<T>(obj: T): T {\n    return this\n        .createMatcher_(jasmine.any(obj.constructor) as any as AsymmetricMatcher) as any as T;\n  }\n\n  anyString(): string {\n    return this.createMatcher_(jasmine.any(String) as any as AsymmetricMatcher) as any as string;\n  }\n\n  anyThing(): any {\n    return this.createMatcher_(jasmine.anything() as any as AsymmetricMatcher);\n  }\n\n  arrayContaining<T>(obj: T[]): T[] {\n    return this.createMatcher_(jasmine.arrayContaining(obj)) as any as T[];\n  }\n\n  private createMatcher_(asymmetricMatcher: AsymmetricMatcher): AsymmetricMatcher {\n    return {\n      asymmetricMatch: (actual: any, ...args: any[]): boolean => {\n        const mappedActual = this.mapFns_.reduce((previous, current) => {\n          return current(previous);\n        }, actual);\n        return asymmetricMatcher.asymmetricMatch(mappedActual, ...args);\n      },\n    };\n  }\n\n  map(mapFn: MapFn<any, any>): MatcherBuilder {\n    const fns = [...this.mapFns_];\n    fns.push(mapFn);\n    return new MatcherBuilder(fns);\n  }\n\n  objectContaining(obj: any): any {\n    return this.createMatcher_(jasmine.objectContaining(obj) as any as AsymmetricMatcher);\n  }\n\n  stringMatching(regexp: RegExp): string {\n    return this.createMatcher_(\n        jasmine.stringMatching(regexp) as any as AsymmetricMatcher) as any as string;\n  }\n}\n\nexport const Matchers = new MatcherBuilder([]);\n// TODO: anyTypeof\n// TODO: anyNumberCloseTo\n","import { AnyAssert } from './any-assert';\n\n\nexport class NumberAssert extends AnyAssert<number> {\n  /**\n   * Checks that the number is close to the given number.\n   */\n  beCloseTo(other: number, precision: number): void {\n    this.getMatchers_().toBeCloseTo(other, precision);\n  }\n}\n// TODO: Mutable\n","import { AnyAssert } from '../jasmine/any-assert';\n\nexport class PromiseAssert<T> extends AnyAssert<Promise<T>> {\n  constructor(\n      private readonly promise_: Promise<T>,\n      private readonly fail_: (message: any) => void,\n      reversed: boolean,\n      expect: (actual: any) => jasmine.Matchers<Promise<T>>) {\n    super(promise_, reversed, expect);\n    if (reversed) {\n      throw new Error('Reversed is not supported for Promise asserts');\n    }\n  }\n\n  async reject(): Promise<any> {\n    try {\n      await this.promise_;\n      return this.fail_(`Expected to reject`);\n    } catch (e) {\n      return e;\n    }\n  }\n\n  async rejectWithError(errorMsg: RegExp): Promise<Error> {\n    return this.rejectWithErrorType<Error>(Error, errorMsg);\n  }\n\n  async rejectWithErrorType<E extends Error>(errorType: gs.ICtor<E>, errorMsg: RegExp): Promise<E> {\n    try {\n      await this.promise_;\n      return this.fail_(`Expected to reject with \"${errorMsg}`) as any;\n    } catch (e) {\n      this.getMatchers_(e).toEqual(jasmine.any(errorType));\n\n      const error = e as E;\n      this.getMatchers_(error.message).toMatch(errorMsg);\n      return error;\n    }\n  }\n\n  /**\n   * @param expected The expected value to resolve with.\n   * @return Promise that will be resolved with the resolved value.\n   */\n  async resolveWith(expected: T): Promise<T> {\n    const resolveValue = await this.promise_;\n    this.getMatchers_(resolveValue).toEqual(expected);\n    return resolveValue;\n  }\n}\n","import { ImmutableSet } from '../immutable';\nimport { AnyAssert } from '../jasmine/any-assert';\n\n\n/**\n * Map related assertions.\n */\nexport class SetAssert<V> extends AnyAssert<Set<V>> {\n  private readonly setValue_: Set<V>;\n\n  /**\n   * @param setValue The value to assert.\n   * @param reversed True iff the assertion logic should be reversed.\n   * @param expect Reference to jasmine's expect function.'\n   */\n  constructor(\n      setValue: Set<V>,\n      reversed: boolean,\n      expect: (actual: any) => jasmine.Matchers<Set<V>>) {\n    super(setValue, reversed, expect);\n    this.setValue_ = setValue;\n  }\n\n  /**\n   * @param elements Elements that the set should have.\n   */\n  haveElements(elements: V[]): void {\n    this.getMatchers_([...ImmutableSet.of(this.setValue_)]).toEqual(elements);\n  }\n}\n","import { AnyAssert } from './any-assert';\n\n\n/**\n * String related assertions.\n */\nexport class StringAssert extends AnyAssert<string> {\n  /**\n   * @param value_ The value to assert.\n   * @param reversed_ True iff the assertion logic should be reversed.\n   * @param expect_ Reference to jasmine's expect function.'\n   */\n  constructor(\n      stringValue: string,\n      reversed: boolean,\n      expect: (actual: any) => jasmine.Matchers<string>) {\n    super(stringValue, reversed, expect);\n  }\n\n  /**\n   * Asserts that the value matches the given regexp.\n   */\n  match(regexp: RegExp): void {\n    this.getMatchers_().toEqual(jasmine.stringMatching(regexp));\n  }\n}\n","type CallSpec = {args: any[], handler: (...args: any[]) => any};\n\n\nclass WhenBuilder {\n  private readonly args_: any[];\n  private readonly callSpecs_: CallSpec[];\n  private readonly spy_: jasmine.Spy;\n\n  constructor(args: any[], spy: jasmine.Spy, callSpecs: CallSpec[]) {\n    this.args_ = args;\n    this.callSpecs_ = callSpecs;\n    this.spy_ = spy;\n  }\n\n  /**\n   * @param handler Function to call if the condition matches.\n   * @return The modified spy object.\n   */\n  call(handler: (...args: any[]) => any): FakesContinuationBuilder {\n    const newCallSpecs = this.callSpecs_.concat([{args: this.args_, handler: handler}]);\n    this.spy_.and.callFake((...args: any[]) => {\n      const callSpec = newCallSpecs.find((callSpec: CallSpec) => {\n        let matches = true;\n        for (let i = 0; i < callSpec.args.length && matches; i++) {\n          const arg = callSpec.args[i];\n          if (typeof arg.jasmineMatches === 'function') {\n            matches = matches && arg.jasmineMatches(args[i]);\n          } else if (typeof arg.asymmetricMatch === 'function') {\n            matches = matches && arg.asymmetricMatch(args[i]);\n          } else if (!(arg instanceof Element) && typeof arg.matches === 'function') {\n            matches = matches && arg.matches(args[i]);\n          } else {\n            matches = matches && (callSpec.args[i] === args[i]);\n          }\n        }\n\n        return matches;\n      });\n\n      if (callSpec !== undefined) {\n        return callSpec.handler(...args);\n      }\n    });\n    return new FakesContinuationBuilder(this.spy_, newCallSpecs);\n  }\n\n  /**\n   * @param value Value to resolve when the condition matches.\n   * @return The modified spy object.\n   */\n  resolve(value?: any): FakesContinuationBuilder {\n    return this.return(Promise.resolve(value));\n  }\n\n  /**\n   * @param value Value to be returned when the condition matches.\n   * @return The modified spy object.\n   */\n  return(value?: any): FakesContinuationBuilder {\n    return this.call(() => value);\n  }\n}\n\n\nclass ElseBuilder {\n  private readonly spy_: jasmine.Spy;\n  private readonly whenBuilder_: WhenBuilder;\n\n  constructor(spy: jasmine.Spy, callSpecs: CallSpec[]) {\n    this.spy_ = spy;\n    this.whenBuilder_ = new WhenBuilder([], spy, callSpecs);\n  }\n\n  /**\n   * @param handler Function to call if the condition matches.\n   * @return The modified spy object.\n   */\n  call(handler: (...args: any[]) => any): jasmine.Spy {\n    this.whenBuilder_.call(handler);\n    return this.spy_;\n  }\n\n  /**\n   * @param value Value to resolve when the condition matches.\n   * @return The modified spy object.\n   */\n  resolve(value?: any): jasmine.Spy {\n    return this.return(Promise.resolve(value));\n  }\n\n  /**\n   * @param value Value to be returned when the condition matches.\n   * @return The modified spy object.\n   */\n  return(value?: any): jasmine.Spy {\n    return this.call(() => value);\n  }\n}\n\n\nclass FakesContinuationBuilder {\n  protected readonly callSpecs_: CallSpec[];\n  protected readonly spy_: jasmine.Spy;\n\n  constructor(spy: jasmine.Spy, callSpecs: CallSpec[]) {\n    this.callSpecs_ = callSpecs;\n    this.spy_ = spy;\n  }\n\n  /**\n   * Starts a condition that always matches.\n   * @return Builder to chain the behavior if the arguments match the call.\n   */\n  else(): ElseBuilder {\n    return new ElseBuilder(this.spy_, this.callSpecs_);\n  }\n\n  /**\n   * Starts a matching condition.\n   * @param args Arguments to match. This also accepts jasmine matchers. If there are less specified\n   *    arguments, the rest of the arguments are assumed to match.\n   * @return Builder to chain the behavior if the arguments match the call.\n   */\n  when(...args: any[]): WhenBuilder {\n    return new WhenBuilder(args, this.spy_, this.callSpecs_);\n  }\n}\n\n\n/**\n * Sets up fake behavior for jasmine Spies.\n */\nexport class Fakes extends FakesContinuationBuilder {\n\n  constructor(spy: jasmine.Spy) {\n    super(spy, []);\n  }\n\n  /**\n   * Calls the given handler always.\n   * @param handler Handler to be called.\n   * @return The modified spy object.\n   */\n  call(handler: (...args: any[]) => any): jasmine.Spy {\n    return this.else().call(handler);\n  }\n\n  /**\n   * @param spy The jasmine spy to set up the behavior for.\n   * @return The Fakes object for chaining.\n   */\n  static build(spy: jasmine.Spy): Fakes {\n    return new Fakes(spy);\n  }\n}\n\n// TODO: Mutable\n","import { BaseDisposable } from '../dispose/base-disposable';\nimport { DisposableFunction } from '../dispose/disposable-function';\n\n\n/**\n * Do not use symbol. Jasmine does not detect symbolic keys for equality checking.\n * @hidden\n */\nconst __id = '$id';\n\n/**\n * Contains various utility methods to create mocks for testing.\n */\nexport class Mocks {\n  /**\n   * Creates a mock builder.\n   *\n   * Each method of the builder returns the instance of the builder.\n   * @param name Name to identify the mock.\n   * @param methods Name of builder methods to generate.\n   * @return The mock builder object.\n   */\n  static builder(name: string, methods: string[]): any {\n    const baseObj = Mocks.object(name);\n    methods.forEach((method: string) => {\n      baseObj[method] = () => {\n        return baseObj;\n      };\n    });\n    return baseObj;\n  }\n\n  /**\n   * Creates a mock disposable object.\n   *\n   * @return The mock disposable object.\n   */\n  static disposable(name: string): any {\n    const mock = new BaseDisposable();\n    mock[__id] = name;\n    return mock;\n  }\n\n  static getter(target: any, name: string, value: any): void {\n    Object.defineProperty(target, name, {\n      get: () => value,\n    });\n  }\n\n  /**\n   * @param items Content of the list.\n   * @return The mock element object.\n   */\n  static itemList<T>(items: T[]): {item: (index: number) => T, length: number} {\n    return {\n      length: items.length,\n      item(index: number): T {\n        return items[index];\n      },\n    };\n  }\n\n  /**\n   * Creates a mock listenable.\n   *\n   * @param name Name to identify the mock object.\n   * @return The mock listenable object.\n   */\n  static listenable(name: string, target?: any): any {\n    const mock = Mocks.disposable(name);\n    mock.on = () => {\n      return new DisposableFunction(() => undefined);\n    };\n    mock.dispatch = () => undefined;\n    mock.getEventTarget = () => target;\n    return mock;\n  }\n\n  /**\n   * Creates a mock object.\n   *\n   * @param name Name to identify the mock object.\n   * @return The mock object instance.\n   */\n  static object(name: string, objType: gs.ICtor<any> = Object): any {\n    const mock = {[__id]: name};\n    Object.setPrototypeOf(mock, objType.prototype);\n    return mock;\n  }\n}\n","import { Parser } from '../interfaces/parser';\n\n\n/**\n * Attribute parser that handles float values.\n */\nexport const FloatParser: Parser<number> = {\n  /**\n   * Parses the given input string.\n   *\n   * @param input The input string.\n   * @return The parsed float value, or NaN if it cannot be parsed.\n   */\n  parse(input: string | null): number | null {\n    if (input === null) {\n      return null;\n    } else {\n      const result = Number.parseFloat(input);\n      return Number.isNaN(result) ? null : result;\n    }\n  },\n\n  /**\n   * Converts the given number to string.\n   *\n   * @param value The number to be converted to string.\n   * @return The string representation of the given number.\n   */\n  stringify(value: number | null): string {\n    if (value === null) {\n      return '';\n    }\n    return value.toString(10);\n  },\n};\n// TODO: Mutable\n","import { ImmutableList } from '../immutable';\nimport { Parser } from '../interfaces';\nimport { AbsolutePath } from '../path/absolute-path';\nimport { Path } from '../path/path';\n\nexport const AbsolutePathParser: Parser<AbsolutePath> = {\n  parse(input: string | null): AbsolutePath | null {\n    if (!input) {\n      return null;\n    }\n\n    const parts = input.split(Path.SEPARATOR);\n\n    if (parts[0] !== '') {\n      // This is not an absolute path.\n      return null;\n    }\n\n    return new AbsolutePath(ImmutableList.of(parts.slice(1)));\n  },\n\n  stringify(value: AbsolutePath | null): string {\n    if (!value) {\n      return '';\n    }\n\n    return value.toString();\n  },\n};\n","import { cache } from '../data';\nimport { Path } from '../path/path';\n\nexport class AbsolutePath extends Path {\n  @cache()\n  toString(): string {\n    return `/${[...this.getParts()].join(Path.SEPARATOR)}`;\n  }\n}\n","export { AbsolutePath } from './absolute-path';\nexport { AbsolutePathParser } from './absolute-path-parser';\nexport { Path } from './path';\nexport { PathParser } from './path-parser';\nexport { Paths } from './paths';\nexport { RelativePath } from './relative-path';\nexport { RelativePathParser } from './relative-path-parser';\n","import { Parser } from '../interfaces';\nimport { AbsolutePathParser } from '../path/absolute-path-parser';\nimport { Path } from '../path/path';\nimport { RelativePathParser } from '../path/relative-path-parser';\n\nexport const PathParser: Parser<Path> = {\n  parse(input: string | null): Path | null {\n    return RelativePathParser.parse(input) || AbsolutePathParser.parse(input);\n  },\n\n  stringify(value: Path | null): string {\n    if (!value) {\n      return '';\n    }\n\n    return value.toString();\n  },\n};\n","import { ImmutableList } from '../immutable';\n\nexport abstract class Path {\n  static readonly SEPARATOR: string = '/';\n\n  private readonly parts_: ImmutableList<string>;\n\n  constructor(parts: Iterable<string>) {\n    this.parts_ = ImmutableList.of([...parts]);\n  }\n\n  getParts(): ImmutableList<string> {\n    return this.parts_;\n  }\n}\n","import { Errors } from '../error';\nimport { ImmutableList } from '../immutable';\nimport { AbsolutePath } from '../path/absolute-path';\nimport { AbsolutePathParser } from '../path/absolute-path-parser';\nimport { Path } from '../path/path';\nimport { RelativePath } from '../path/relative-path';\nimport { RelativePathParser } from '../path/relative-path-parser';\nimport { assertUnreachable } from '../typescript';\n\nexport class Paths {\n  static absolutePath(pathString: string): AbsolutePath {\n    const path = AbsolutePathParser.parse(pathString);\n    if (!path) {\n      throw Errors.assert('pathString').shouldBe('a valid absolute path').butWas(pathString);\n    }\n    return path;\n  }\n\n  static getDirPath(path: AbsolutePath): AbsolutePath;\n  static getDirPath(path: RelativePath): RelativePath;\n  static getDirPath(path: AbsolutePath | RelativePath): Path {\n    const parts = path.getParts().slice(0, -1);\n    if (path instanceof AbsolutePath) {\n      return new AbsolutePath(parts);\n    } else if (path instanceof RelativePath) {\n      return new RelativePath(parts);\n    } else {\n      throw assertUnreachable(path);\n    }\n  }\n\n  static getFilenameParts(filename: string): {extension: string, name: string} {\n    const parts = filename.split('.');\n    const extensionIndex = Math.max(1, parts.length - 1);\n    const extension = parts[extensionIndex] || '';\n    return {\n      extension,\n      name: parts.slice(0, extensionIndex).join('.'),\n    };\n  }\n\n  static getItemName(path: Path): string | null {\n    const parts = path.getParts();\n    return parts.getAt(-1) || null;\n  }\n\n  static getRelativePath(srcPath: AbsolutePath, destPath: AbsolutePath): RelativePath {\n    let commonCount = 0;\n    const thisParts = srcPath.getParts();\n    const thatParts = destPath.getParts();\n    while (commonCount < Math.min(thisParts.size(), thatParts.size()) - 1) {\n      if (thisParts.getAt(commonCount) !== thatParts.getAt(commonCount)) {\n        break;\n      }\n\n      commonCount++;\n    }\n\n    const upCount = thisParts.size() - commonCount;\n    const parts: string[] = [];\n    for (let i = 0; i < upCount; i++) {\n      parts.push('..');\n    }\n\n    return new RelativePath(ImmutableList.of(parts).addAll(thatParts.slice(upCount)));\n  }\n\n  /**\n   * @param path Path to return the subpaths to.\n   * @return Subpaths to the root from the given path. For example, if path is '/a/b/c', this would\n   *     return ['/a/b/c', '/a/b', '/a', '/'].\n   */\n  static getSubPathsToRoot(path: AbsolutePath): ImmutableList<AbsolutePath> {\n    const subpaths: AbsolutePath[] = [];\n    let currentPath = path;\n    while (currentPath && currentPath.getParts().size() > 0) {\n      subpaths.push(currentPath);\n      currentPath = Paths.getDirPath(currentPath);\n    }\n\n    return ImmutableList.of(subpaths);\n  }\n\n  static join(root: AbsolutePath, ...paths: RelativePath[]): AbsolutePath;\n  static join(root: RelativePath, ...paths: RelativePath[]): RelativePath;\n  static join(root: AbsolutePath | RelativePath, ...paths: RelativePath[]): Path {\n    const srcParts = [...root.getParts()];\n    for (const path of paths) {\n      for (const part of path.getParts()) {\n        srcParts.push(part);\n      }\n    }\n\n    if (root instanceof AbsolutePath) {\n      return Paths.normalize(new AbsolutePath(ImmutableList.of(srcParts)));\n    } else if (root instanceof RelativePath) {\n      return Paths.normalize(new RelativePath(ImmutableList.of(srcParts)));\n    } else {\n      throw assertUnreachable(root);\n    }\n  }\n\n  static normalize(path: AbsolutePath): AbsolutePath;\n  static normalize(path: RelativePath): RelativePath;\n  static normalize(path: AbsolutePath | RelativePath): Path {\n    // Removes all instances of '' parts.\n    const noEmptyParts = [...path.getParts().filter((part) => !!part)];\n\n    // Removes all instances of '.' part except the first one.\n    const noCurrentParts: string[] = [];\n    for (let i = 0; i < noEmptyParts.length; i++) {\n      const part = noEmptyParts[i];\n      if (i === 0 || part !== '.') {\n        noCurrentParts.push(part);\n      }\n    }\n\n    // Copy all trailing '..' part.\n    const nonDoubleDotEntry = ImmutableList.of(noCurrentParts).findEntry((part) => part !== '..');\n    const nonDoubleIndex = nonDoubleDotEntry ? nonDoubleDotEntry[0] + 1 : 0;\n    const normalizedParts: string[] = [];\n    for (let i = 0; i < nonDoubleIndex; i++) {\n      normalizedParts.push(noCurrentParts[i]);\n    }\n\n    for (let i = nonDoubleIndex; i < noCurrentParts.length; i++) {\n      const part = noCurrentParts[i];\n      if (part === '..'\n          && normalizedParts.length > 0\n          && normalizedParts[normalizedParts.length - 1] !== '..') {\n        normalizedParts.pop();\n      } else {\n        normalizedParts.push(part);\n      }\n    }\n\n    if (path instanceof AbsolutePath) {\n      return new AbsolutePath(ImmutableList.of(normalizedParts));\n    } else if (path instanceof RelativePath) {\n      return new RelativePath(ImmutableList.of(normalizedParts));\n    } else {\n      throw assertUnreachable(path);\n    }\n  }\n\n  static relativePath(pathString: string): RelativePath {\n    const path = RelativePathParser.parse(pathString);\n    if (!path) {\n      throw Errors.assert('pathString').shouldBe('a valid relative path').butWas(pathString);\n    }\n    return path;\n  }\n\n  static setFilenameExt(filename: string, extension: string): string {\n    const {name} = Paths.getFilenameParts(filename);\n\n    if (!extension) {\n      return name;\n    }\n    return `${name}.${extension}`;\n  }\n}\n","import { ImmutableList } from '../immutable';\nimport { Parser } from '../interfaces';\nimport { Path } from '../path/path';\nimport { RelativePath } from '../path/relative-path';\n\nexport const RelativePathParser: Parser<RelativePath> = {\n  parse(input: string | null): RelativePath | null {\n    if (!input) {\n      return null;\n    }\n\n    const parts = input.split(Path.SEPARATOR);\n\n    if (parts[0] === '') {\n      // This is an abolute path.\n      return null;\n    }\n\n    return new RelativePath(ImmutableList.of(parts));\n  },\n\n  stringify(value: RelativePath | null): string {\n    if (!value) {\n      return '';\n    }\n\n    return value.toString();\n  },\n};\n","import { cache } from '../data';\nimport { Path } from '../path/path';\n\nexport class RelativePath extends Path {\n  @cache()\n  toString(): string {\n    return `${[...this.getParts()].join(Path.SEPARATOR)}`;\n  }\n}\n","export { PathMatcher } from './path-matcher';\n","import { Path } from '../../path';\nimport { ITestSetup, Matcher, matcherTestSetup } from '../../testing';\n\nexport class PathMatcher implements Matcher {\n  static readonly testSetup: ITestSetup = matcherTestSetup(PathMatcher);\n\n  constructor(private readonly pathString_: string) { }\n\n  matches(other: any): boolean {\n    if (!(other instanceof Path)) {\n      return false;\n    }\n\n    return other.toString() === this.pathString_;\n  }\n\n  static with(pathString: string): Path {\n    return new PathMatcher(pathString) as any as Path;\n  }\n}\n","import { TestGraph } from './graph';\nimport { PathMatcher } from './path/testing';\nimport { TestAsync, TestDispose, TestEvent, TestJasmine, TestSetup } from './testing';\nimport { Log, LogLevel } from './util/log';\nexport { assert } from './jasmine/assert';\nexport { assertColor } from './jasmine/assert-color';\nexport { Matchers } from './jasmine/matchers';\nexport { Fakes } from './mock/fakes';\nexport { Mocks } from './mock/mocks';\n\nconst TEST_SETUP = new TestSetup([\n  PathMatcher.testSetup,\n  TestAsync,\n  TestDispose,\n  TestEvent,\n  TestGraph,\n  TestJasmine,\n]);\n\nlet initialized = false;\nexport const TestBase = {\n  setup(): void {\n    if (!initialized) {\n      TEST_SETUP.setup();\n      Log.setEnabledLevel(LogLevel.OFF);\n      initialized = true;\n    }\n  },\n};\n","export { ITestSetup } from './i-test-setup';\nexport { Matcher } from './matcher';\nexport { matcherTestSetup } from './matcher-test-setup';\nexport { TestAsync } from './test-async';\nexport { TestDispose } from './test-dispose';\nexport { TestEvent } from './test-event';\nexport { TestInject } from './test-inject';\nexport { TestJasmine } from './test-jasmine';\nexport { TestSetup } from './test-setup';\n","import { ITestSetup } from '../testing/i-test-setup';\nimport { Matcher } from '../testing/matcher';\n\nexport function matcherTestSetup(ctor: gs.ICtor<Matcher>): ITestSetup {\n  return {\n    afterEach(): void {},\n\n    beforeEach(): void {\n      jasmine.addCustomEqualityTester((first: any, second: any): boolean | undefined => {\n        if (first instanceof ctor) {\n          return first.matches(second);\n        }\n\n        if (second instanceof ctor) {\n          return second.matches(first);\n        }\n\n        return undefined;\n      });\n    },\n\n    init(): void {},\n  };\n}\n","import { Asyncs } from '../async/asyncs';\n\n/**\n * Test setup object for testing any code using code from the `async` directory.\n *\n * This replaces `Asyncs.run` to run synchronously to make testing easier.\n */\nexport const TestAsync = {\n  /**\n   * Runs the code in jasmine's `afterEach` logic.\n   */\n  afterEach(): void {\n    // Noop\n  },\n\n  /**\n   * Runs the code in jasmine's `beforeEach` logic.\n   */\n  beforeEach(): void {\n    spyOn(Asyncs, 'run').and.callFake((fn: () => any) => {\n      return fn();\n    });\n  },\n\n  init(): void { },\n};\n","import { Flags, TRACKED_DISPOSABLES } from '../dispose/base-disposable';\nimport { Disposable } from '../interfaces/disposable';\n\n\n/**\n * @hidden\n */\nconst DISPOSABLES: Disposable[] = [];\n\n/**\n * Test setup object for testing any code using code from the `dispose` directory.\n *\n * This checks that all [[BaseDisposable]] objects are disposed at the end of the test. Objects that\n * need to be disposed manually (because they should be disposed through some flow not covered by\n * the test) can be disposed by using the [[add]] method.\n */\nexport const TestDispose = {\n  /**\n   * Adds the given disposables to be disposed at the end of the test.\n   * @param ...disposables Disposables to be disposed at the end of the test.\n   */\n  add(...disposables: Disposable[]): void {\n    disposables.forEach((disposable: Disposable) => {\n      DISPOSABLES.push(disposable);\n    });\n  },\n\n  /**\n   * Runs the code in jasmine's `afterEach` logic.\n   */\n  afterEach(): void {\n    DISPOSABLES.forEach((disposable: Disposable) => disposable.dispose());\n    Flags.enableTracking = false;\n\n    expect(TRACKED_DISPOSABLES).toEqual([]);\n\n    TRACKED_DISPOSABLES.splice(0, TRACKED_DISPOSABLES.length);\n  },\n\n  /**\n   * Runs the code in jasmine's `beforeEach` logic.\n   */\n  beforeEach(): void {\n    DISPOSABLES.splice(0, DISPOSABLES.length);\n    Flags.enableTracking = true;\n  },\n\n  init(): void { },\n};\n","import { BaseListenable } from '../event/base-listenable';\n\nimport { TestDispose } from '../testing/test-dispose';\nimport { deprecated } from '../typescript/deprecated';\nimport { Log } from '../util/log';\n\n/**\n * @hidden\n */\nconst __calls = Symbol('calls');\n\nconst LOGGER = Log.of('testing.TestEvent');\n\n\nexport class TestEvent {\n\n  /**\n   * Runs the code in jasmine's `afterEach` logic.\n   */\n  static afterEach(): void {\n    // Noop\n  }\n\n  /**\n   * Runs the code in jasmine's `beforeEach` logic.\n   */\n  static beforeEach(): void {\n    // Noop\n  }\n\n  @deprecated(LOGGER, `Use 'spyOn dispatchEvent'`)\n  static getPayloads<E>(target: BaseListenable<E>, eventType: E): any[] {\n    if (!target[__calls]) {\n      throw Error(`Target ${target} has not been spied on`);\n    }\n\n    return target[__calls].get(eventType) || [];\n  }\n\n  static init(): void { }\n\n  @deprecated(LOGGER, `Use 'spyOn dispatchEvent'`)\n  static spyOn<E>(target: BaseListenable<E>, eventTypes: E[]): any {\n    if (!target[__calls]) {\n      target[__calls] = new Map<E, any[]>();\n    }\n\n    eventTypes.forEach((eventType: E) => {\n      TestDispose.add(target.on(eventType, (payload: any) => {\n        if (!target[__calls].has(eventType)) {\n          target[__calls].set(eventType, []);\n        }\n\n        target[__calls].get(eventType).push(payload);\n      }, this));\n    });\n  }\n}\n","import { Injector } from '../inject/injector';\n\n\nconst BOUND_VALUES_: Map<string | symbol, any> = new Map();\n\n/**\n * Test setup object for testing any code using code from the `dispose` directory.\n *\n * This checks that all [[BaseDisposable]] objects are disposed at the end of the test. Objects that\n * need to be disposed manually (because they should be disposed through some flow not covered by\n * the test) can be disposed by using the [[add]] method.\n */\nexport const TestInject = {\n\n  /**\n   * Gets the value bound for the given key.\n   *\n   * @param bindKey The binding key.\n   * @return The value bound to the given key.\n   */\n  getBoundValue(bindKey: string | symbol): any {\n    return BOUND_VALUES_.get(bindKey);\n  },\n\n  /**\n   * Runs the code in jasmine's `afterEach` logic.\n   */\n  afterEach(): void { },\n\n  /**\n   * Runs the code in jasmine's `beforeEach` logic.\n   */\n  beforeEach(): void {\n    BOUND_VALUES_.clear();\n    spyOn(Injector, 'bind').and.callFake((ctor: gs.ICtor<any>, bindKey: string | symbol) => {\n      BOUND_VALUES_.set(bindKey, ctor);\n    });\n    spyOn(Injector, 'bindProvider').and\n        .callFake((provider: (injector: Injector) => any, bindKey: string | symbol) => {\n          BOUND_VALUES_.set(bindKey, provider);\n        });\n  },\n\n  init(): void { },\n};\n","/**\n * Test setup object for using jasmine.\n *\n * This introduces new utility methods for jasmine, such as:\n *\n * -   `calls.firstArgsMatching`: The input parameters are exactly the same as\n *     `toHaveBeenCalledWith`. This returns the first arguments that matches the input parameters.\n */\nimport { Log } from '../util/log';\n\nexport const TestJasmine = {\n  /**\n   * Runs the code in jasmine's `afterEach` logic.\n   */\n  afterEach(): void {},\n\n  /**\n   * Runs the code in jasmine's `beforeEach` logic.\n   */\n  beforeEach(): void {\n    Log.setColorEnabled(false);\n  },\n\n  init(): void {\n    function runTest(origRun: any, description: string, callback: (done: any) => any): void {\n      if (!callback) {\n        origRun(description, callback);\n        return;\n      }\n\n      origRun(description, (done: any) => {\n        const promise = callback(done);\n        if (promise instanceof Promise) {\n          promise.then(done, done.fail);\n        } else {\n          done();\n        }\n      });\n    }\n\n    if (!window['jasminePatched']) {\n      window['fit'] = runTest.bind(window, fit);\n      window['it'] = runTest.bind(window, it);\n      window['jasminePatched'] = true;\n    }\n\n    jasmine['MAX_PRETTY_PRINT_DEPTH'] = 2;\n    jasmine['MAX_PRETTY_PRINT_ARRAY_LENGTH'] = 5;\n  },\n};\n","import { ITestSetup } from './i-test-setup';\n\n/**\n * Sets up testing logic for your project.\n *\n * Each directory in `gs-tools` may contain special testing logic. Whenever you use them in your\n * project, you want to install the corresponding test setup file for tests in your project.\n *\n * A recommended way to use this is to create a `test-base.ts` file in your project to set up the\n * `TestSetup` and include the `test-base` in every test. This `test-base` class should install the\n * test setup plugins to use, and call [[setup]] once during the test.\n *\n * Example `test-base` file:\n *\n * ```typescript\n * import TestDispose from './testing/test-dispose';\n * import TestSetup from './testing/test-setup';\n *\n * const testSetup = new TestSetup([TestDispose]);\n * let initialized = false;\n * export default = {\n *   setup() {\n *     if (!initialized) {\n *       testSetup.setup();\n *       initialized = true;\n *     }\n *   }\n * };\n * ```\n *\n * In your test:\n *\n * ```\n * import { TestBase } from '../test-base';\n * TestBase.setup();\n *\n * import DisposableClass from './disposable-class';\n * import TestDispose from './testing/test-dispose';\n *\n * describe('Some disposable class', () => {\n *   it('should do something', () => {\n *     let disposableClass = new DisposableClass();\n *\n *     // Without this, TestDispose will complain that disposableClass does not get disposed at the\n *     // end of the test.\n *     TestDispose.add(disposableClass);\n *   });\n * });\n * ```\n */\nexport class TestSetup {\n  private setups_: ITestSetup[];\n\n  constructor(setups: ITestSetup[]) {\n    this.setups_ = setups;\n  }\n\n  setup(): void {\n    this.setups_.forEach((setup: ITestSetup) => {\n      setup.init();\n    });\n\n    beforeEach(() => {\n      this.setups_.forEach((setup: ITestSetup) => {\n        setup.beforeEach();\n      });\n    });\n\n    afterEach(() => {\n      this.setups_.forEach((setup: ITestSetup) => {\n        setup.afterEach();\n      });\n    });\n  }\n}\n","export function assertUnreachable(_: never): never {\n  throw new Error('Unreachable code reached');\n}\n","import { Log } from '../util/log';\n\nexport function deprecated(log: Log, message: string): MethodDecorator {\n  return function(\n      _: Object,\n      propertyKey: string | symbol,\n      descriptor: TypedPropertyDescriptor<any>): TypedPropertyDescriptor<any> {\n    const origValue = descriptor.value;\n    descriptor.value = function(...args: any[]): any {\n      Log.warn(log, propertyKey.toString(), 'is deprecated:', message);\n      return origValue.apply(this, args);\n    };\n    return descriptor;\n  };\n}\n","/**\n * Utility methods to work with typescript's enums.\n */\nexport class Enums {\n\n  /**\n   * Converts enum name (as lower case string) to the corresponding enum value.\n   *\n   * @param stringValue The string value to convert to enum value.\n   * @param enumSet The set of enum values.\n   * @return The enum value corresponding to the enum name.\n   */\n  static fromLowerCaseString<E>(stringValue: string, enumSet: gs.IEnum): E {\n    return enumSet[stringValue.toUpperCase()];\n  }\n\n  /**\n   * Converts enum number (as string) to the corresponding enum value.\n   *\n   * @param stringValue The number to convert to enum value.\n   * @param enumSet The set of enum values.\n   * @return The enum value corresponding to the enum number.\n   */\n  static fromNumberString<E>(stringValue: string, enumSet: gs.IEnum): E {\n    const nameString: string = enumSet[stringValue];\n    return enumSet[nameString] as E;\n  }\n\n  /**\n   * Returns all values of the given enum.\n   *\n   * @param enumSet Enum whose values should be returned.\n   * @return Array of enum values.\n   */\n  static getAllValues<E>(enumSet: gs.IEnum): E[] {\n    const values: E[] = [];\n    let index = 0;\n    while (enumSet[index] !== undefined) {\n      values.push(index as any as E);\n      index++;\n    }\n\n    return values;\n  }\n\n  /**\n   * Converts the given enum value to lower case version of its name.\n   *\n   * @param enumValue The enum value to convert.\n   * @param enumSet The set of enum values.\n   * @return The lower case version of the enum name that corresponds to the enum value.\n   */\n  static toLowerCaseString(enumValue: any, enumSet: gs.IEnum): string {\n    return enumSet[enumValue].toLowerCase();\n  }\n}\n","export function equals(item1: any, item2: any): boolean {\n  if (item1 === item2) {\n    return true;\n  }\n\n  if (item1 instanceof Function && item2 instanceof Function) {\n    return item1 === item2;\n  } else if (item1 instanceof Object && item2 instanceof Object) {\n    if (!(item1 instanceof item2.constructor) ||\n        !(item2 instanceof item1.constructor)) {\n      return false;\n    }\n\n    for (const key in item1) {\n      if (!equals(item1[key], item2[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else {\n    return item1 === item2;\n  }\n}\n","export function forceImport(obj: any): void {\n  console.debug('Force import', obj);\n}\n","export { assertUnreachable } from './assert-unreachable';\nexport { deprecated } from './deprecated';\nexport { Enums } from './enums';\nexport { equals } from './equals';\nexport { forceImport } from './force-import';\nexport { isDescendantOf } from './is-descendant-of';\n","export function isDescendantOf(descendantCtor: Function, ancestorCtor: Function): boolean {\n  return descendantCtor.prototype instanceof ancestorCtor;\n}\n","export const HASHED_VALUES: Map<any, number> = new Map();\nexport const HASHED_OBJECTS: WeakMap<Object, number> = new WeakMap();\nexport const GLOBALS = {lastHash: 0};\n\n\ntype MapLike<K, V> = {\n  get(key: K): V | undefined;\n  has(key: K): boolean;\n  set(key: K, value: V): void;\n};\n\nexport function hash(object: Object): string;\nexport function hash(object: any): string {\n  const mapLike: MapLike<any, number> = object instanceof Object ? HASHED_OBJECTS : HASHED_VALUES;\n  if (!mapLike.has(object)) {\n    mapLike.set(object, GLOBALS.lastHash);\n    GLOBALS.lastHash++;\n  }\n  return `${mapLike.get(object)}`;\n}\n// TODO: Mutable\n","export { Log, LogLevel } from './log';\nexport { Reflect } from './reflect';\n","/**\n * Wrapper around `console.log`.\n *\n * This adds namespace to the start of every log. You can also enable / disable logging using the\n * [[setEnabled]] method.\n *\n * Example usage:\n *\n * ```typescript\n * import Log from './log';\n *\n * const LOG = new Log('namespace');\n *\n * Log.error(LOG, 'Error message');\n * ```\n */\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARNING = 2,\n  ERROR = 3,\n  OFF = 4,\n}\n\nexport class Log {\n  private static COLOR_ENABLED_: boolean = true;\n  private static ENABLED_LOG_LEVEL_: LogLevel = LogLevel.INFO;\n\n  private readonly currentIds_: string[] = [];\n  private readonly loggedIds_: Set<string> = new Set();\n  private namespace_: string;\n\n  /**\n   * @param namespace Namespace of the log messages.\n   */\n  constructor(namespace: string) {\n    this.namespace_ = namespace;\n  }\n\n  private callIfEnabled_(\n      fn: (message: string, ...args: any[]) => void,\n      logLevel: LogLevel,\n      color: string,\n      ...messages: any[]): void {\n    const currentId = this.currentIds_.length > 0\n        ? this.currentIds_[this.currentIds_.length - 1]\n        : null;\n    if ((!currentId || !this.loggedIds_.has(currentId)) && logLevel >= Log.ENABLED_LOG_LEVEL_) {\n      const usedColor = Log.COLOR_ENABLED_ ? color : 'default';\n      fn(\n          `%c${this.namespace_}%c`,\n          `color: ${usedColor}`,\n          `color: default`,\n          ...messages);\n    }\n  }\n\n  static debug(log: Log, ...messages: any[]): void {\n    log.callIfEnabled_(\n        console.debug.bind(console), LogLevel.DEBUG, '#8000ff', ...messages);\n  }\n\n  /**\n   * Logs error message\n   *\n   * @param log The log object.\n   * @param message The message to log.\n   */\n  static error(log: Log, ...messages: any[]): void {\n    log.callIfEnabled_(\n        console.error.bind(console), LogLevel.ERROR, '#800000', ...messages);\n  }\n\n  static getEnabledLevel(): LogLevel {\n    return Log.ENABLED_LOG_LEVEL_;\n  }\n\n  static groupCollapsed(log: Log, ...messages: any[]): void {\n    log.callIfEnabled_(\n        console.groupCollapsed.bind(console), LogLevel.INFO, '#808080', ...messages);\n  }\n\n  static groupEnd(log: Log): void {\n    log.callIfEnabled_(console.groupEnd.bind(console), LogLevel.INFO, '');\n  }\n\n  /**\n   * Logs info message.\n   *\n   * @param log The log object.\n   * @param message The message to log.\n   */\n  static info(log: Log, ...messages: any[]): void {\n    log.callIfEnabled_(console.info.bind(console), LogLevel.INFO, '#00bfff', ...messages);\n  }\n\n  static of(namespace: string): Log {\n    return new Log(namespace);\n  }\n\n  static onceEnd(log: Log, id: string): void {\n    log.loggedIds_.add(id);\n    log.currentIds_.pop();\n  }\n\n  static onceId(log: Log, id: string): void {\n    log.currentIds_.push(id);\n  }\n\n  static setColorEnabled(enabled: boolean): void {\n    Log.COLOR_ENABLED_ = enabled;\n  }\n\n  /**\n   * Sets the enabled logging level..\n   */\n  static setEnabledLevel(logLevel: LogLevel): void {\n    Log.ENABLED_LOG_LEVEL_ = logLevel;\n  }\n\n  static trace(log: Log): void {\n    log.callIfEnabled_(console.trace.bind(console), LogLevel.DEBUG, '');\n  }\n\n  /**\n   * Logs warning message.\n   *\n   * @param log The log object.\n   * @param message The message to log.\n   */\n  static warn(log: Log, ...messages: any[]): void {\n    log.callIfEnabled_(console.warn.bind(console), LogLevel.WARNING, '#ff9f00', ...messages);\n  }\n}\n","/**\n * Reflection utility methods.\n *\n * This is a wrapper around the standard Reflect library as it adds more features.\n */\nexport class Reflect {\n  /**\n   * Symbol on a class to reference a static function to initialize instances of that class. The\n   * function should accept the instance to be initialized.\n   * @static\n   */\n  static __initialize: symbol = Symbol('initialize');\n\n  static addInitializer(ctor: gs.ICtor<any>, initializer: (...args: any[]) => void): any {\n    const origInitializer = ctor.prototype[Reflect.__initialize];\n    ctor.prototype[Reflect.__initialize] = function(...args: any[]): void {\n      if (origInitializer) {\n        origInitializer.apply(this, args);\n      }\n      initializer.apply(this, args);\n    };\n  }\n\n  /**\n   * Constructs a new instance of the constructor with the given arguments. If the constructor has\n   * a function referenced by the `__initialize` symbol, that function will be called with the\n   * new instance as its input argument.\n   *\n   * @param ctor The constructor to construct a new instance of.\n   * @param args Arguments to apply to the constructor.\n   * @return The new instance created from the constructor.\n   */\n  static construct(ctor: gs.ICtor<any>, args: any[]): any {\n    const instance = new (ctor.bind.apply(ctor, [null].concat(args)));\n    if (instance[Reflect.__initialize] instanceof Function) {\n      instance[Reflect.__initialize](instance);\n    }\n    return instance;\n  }\n\n  /**\n   * Overrides the getter of the given object.\n   *\n   * @param object The object whose getter property should be overridden.\n   * @param propertyName Name of the getter property to be overridden.\n   * @param newValue The new value returned by the getter.\n   */\n  static overrideGetter(object: any, propertyName: string, newValue: any): void {\n    Object.defineProperty(object, propertyName, { get: (): any => newValue });\n  }\n}\n","/**\n * Collection of miscellaneous methods to do asynchronous operations.\n */\nexport class Asyncs {\n  /**\n   * Runs the given function asynchronously.\n   *\n   * @param <T> Return type of the given function.\n   * @param fn The function to run.\n   * @return Promise that will be resolved when the function has finished running.\n   */\n  static run<T>(fn: () => T): Promise<T> {\n    return new Promise((resolve: Function) => {\n      window.setTimeout(() => {\n        resolve(fn());\n      }, 0);\n    });\n  }\n}\n","import { BaseDisposable } from '../dispose/base-disposable';\n\nimport { Errors } from '../error';\nimport { Sequencer } from './sequencer';\n\nexport const __SEQUENCER: symbol = Symbol('sequencer');\n\n\n/**\n * Annotates a method to indicate that only one instance of the method can be ran at a time.\n */\nexport function atomic(): MethodDecorator {\n  return function(\n      target: Object,\n      _: string | symbol,\n      descriptor: TypedPropertyDescriptor<any>):\n      TypedPropertyDescriptor<any> {\n    if (!(target instanceof BaseDisposable)) {\n      throw Errors.assert('target').shouldBeAnInstanceOf(BaseDisposable).butWas(target);\n    }\n\n    const originalFn = descriptor.value;\n    if (originalFn !== undefined) {\n      descriptor.value = function(this: any, ...args: any[]): any {\n        if (!this[__SEQUENCER]) {\n          const sequencer = Sequencer.newInstance();\n          this[__SEQUENCER] = sequencer;\n          (this as BaseDisposable).addDisposable(sequencer);\n        }\n        return this[__SEQUENCER].run(() => {\n          return Promise.resolve(originalFn!.apply(this, args));\n        });\n      };\n    }\n    return descriptor;\n  };\n}\n","import 'jasmine';\n\nimport { assert, Matchers, TestBase } from '../test-base';\nTestBase.setup();\n\nimport { BaseDisposable } from '../dispose/base-disposable';\nimport { Mocks } from '../mock/mocks';\n\nimport { __SEQUENCER, atomic } from './atomic';\nimport { Sequencer } from './sequencer';\n\n\ndescribe('async.atomic', () => {\n  let decorator: MethodDecorator;\n\n  beforeEach(() => {\n    decorator = atomic();\n  });\n\n  it('should replace the descriptor with a function that sequence the annotated function',\n      async () => {\n    class Class extends BaseDisposable {}\n\n    const mockFunction = jasmine.createSpy('Function');\n\n    const property = 'property';\n    const descriptor = Mocks.object('descriptor');\n    descriptor.value = mockFunction;\n\n    const mockSequencer = jasmine.createSpyObj('Sequencer', ['dispose', 'run']);\n    mockSequencer.run.and.returnValue(Promise.resolve());\n    spyOn(Sequencer, 'newInstance').and.returnValue(mockSequencer);\n\n    const newDescriptor = decorator(Class.prototype, property, descriptor);\n    assert(newDescriptor).to.equal(descriptor);\n\n    const mockInstance = jasmine.createSpyObj('Instance', ['addDisposable']);\n    await descriptor.value.call(mockInstance, 1, 2);\n\n    assert(mockSequencer.run).to.haveBeenCalledWith(Matchers.anyFunction());\n    mockSequencer.run.calls.argsFor(0)[0]();\n\n    assert(mockFunction).to.haveBeenCalledWith(1, 2);\n  });\n\n  it('should reuse existing sequencer', async () => {\n    class Class extends BaseDisposable {}\n\n    const descriptor = Mocks.object('descriptor');\n    descriptor.value = () => {};\n\n    const mockSequencer = jasmine.createSpyObj('Sequencer', ['run']);\n    mockSequencer.run.and.returnValue(Promise.resolve());\n\n    const instance = Mocks.object('instance');\n    instance[__SEQUENCER] = mockSequencer;\n\n    const decoratorInstance =\n        decorator(Class.prototype, 'property', descriptor) as TypedPropertyDescriptor<any>;\n    const decoratedFunction = decoratorInstance.value as Function;\n    await decoratedFunction.call(instance, 1, 2);\n    assert(mockSequencer.run).to.haveBeenCalledWith(Matchers.anyFunction());\n  });\n\n  it('should not throw error if the descriptor has no values', () => {\n    class Class extends BaseDisposable {}\n\n    const descriptor = Mocks.object('descriptor');\n    assert(decorator(Class.prototype, 'property', descriptor)).to.equal(descriptor);\n  });\n\n  it('should throw error if the target is not an instance of BaseDisposable', () => {\n    class Class {}\n    assert(() => {\n      decorator(Class.prototype, 'property', {});\n    }).to.throwError(/should be an instance of \\[BaseDisposable\\]/);\n  });\n});\n","import { BaseDisposable } from '../dispose/base-disposable';\n\n\n/**\n * Takes several operations and makes sure that only one of them runs at any time, in a sequence.\n */\nexport class Sequencer extends BaseDisposable {\n  private lastOperation_: Promise<void> = Promise.resolve();\n\n  /**\n   * Runs the given operation after the previous one has finished running.\n   */\n  run<T>(operation: () => Promise<T>): Promise<void> {\n    const newPromise = this.lastOperation_\n        .then(() => {\n          if (!this.isDisposed()) {\n            operation();\n          }\n        })\n        .catch((error: any) => {\n          if (!this.isDisposed()) {\n            operation();\n          } else {\n            throw error;\n          }\n        });\n    this.lastOperation_ = newPromise;\n    return newPromise;\n  }\n\n  /**\n   * Creates a new instance of the sequencer.\n   */\n  static newInstance(): Sequencer {\n    return new Sequencer();\n  }\n}\n","module.exports = jasmine;"],"sourceRoot":""}